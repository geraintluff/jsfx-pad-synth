desc:PadSynth
in_pin:none;
out_pin:Left
out_pin:Right
options:want_all_kb

import ui-lib.jsfx-inc

@init

// can_recompute = 0;
// action_recompute = 0;
// recompute_index - zero initially;
recompute_chunk = 1; // Recompute at most one waveform per block, so that we don't freeze the UI completely
polyphony = 64;
invsrate = 1/srate;

fftblock = 0;
fftblock_end = 65536;

uiblock_end = ui_setup(fftblock_end);

// Description of all effects in the system
fx_spec_start = uiblock_end;
fx_spec_count = FX_SPECLIST_INDEX##;
fx_spec_headerlength = FX_HEADER##;
fx_spec_modlength = FX_MOD##;
fx_spec_var_count = 10; // Maximum number of modulatable parameters
fx_spec_step = fx_spec_headerlength + fx_spec_modlength*fx_spec_var_count;
fx_spec_end = fx_spec_start + fx_spec_step*fx_spec_count;

fx_list_start = fx_spec_end;
//fx_list_count = 0; // Don't actually reset it here, it'll wipe all effects on playback restart!
fx_list_maxcount = 10;
fx_list_headerlength = FX##;
fx_list_statelength = 16;
fx_list_step = fx_list_headerlength + fx_list_statelength;
fx_list_end = fx_list_start + fx_list_step*fx_list_maxcount;

// First N string slots are reserved for effect names
string_fx_names_start = 1; // So we don't mistake 0 for a valid index
string_fx_names_end = fx_list_maxcount;

notes_start = fx_list_end;
note_headerlength = NOTE#;

note_fx_statelength = fx_list_statelength;
notes_step = note_headerlength + note_fx_statelength*fx_list_maxcount;
notes_end = notes_start + polyphony*notes_step;
// Clear all notes
function clear_all_notes() local(note) (
	note = notes_start;
	while (
		note[NOTE#ACTIVE] = 0;
		note += notes_step;
		note < notes_end;
	);
);
clear_all_notes();

wavetables_start = notes_end;
wavetables_count = 18;
wavetable_sampleslength = 32768;
wavetable_headerlength = WAVETABLE##; // Freq
wavetable_step = wavetable_headerlength + wavetable_sampleslength*2;
wavetables_end = wavetables_start + wavetables_count*wavetable_step;

display_wavetable_index = floor(wavetables_count/2);

volume_db = -12;
volume = pow(10, volume_db/20);
note_maxduration = 60*60*24*365;

wavetable_maxfreq = 18000;
wavetable_refsrate = 48000;
// 6+ octaves, centred on 440
wavetable_low = 50;
wavetable_high = 4000;

// Spec for LFO
LFO_NOTE_STATE## > note_fx_statelength ? ui_error("note state too small for LFO");
LFO_STATE## > fx_list_statelength ? ui_error("effect state too small for LFO");
effectspec = fx_spec_start + fx_spec_count*FX_SPECLIST_INDEX#LFO(0);
effectspec[FX_HEADER#NAME] = "LFO";
effectspec[FX_HEADER#MODCOUNT] = 2;
modspec = effectspec + fx_spec_headerlength + fx_spec_modlength*LFO_NOTE_STATE#LOG_FREQ(0);
modspec[FX_MOD#NAME] = "Frequency";
modspec[FX_MOD#TYPE] = FX_MODTYPE#ADD;
modspec[FX_MOD#RANGE] = 2;
modspec = effectspec + fx_spec_headerlength + fx_spec_modlength*LFO_NOTE_STATE#AMP(1);
modspec[FX_MOD#NAME] = "Amount";
modspec[FX_MOD#TYPE] = FX_MODTYPE#MULT;
modspec[FX_MOD#RANGE] = 1;

effectspec[FX_HEADER#FUNC_INIT] = {effect_init}effect_init_lfo;
function effect_init_lfo(effect) local(mods, state) (
	effect[FX#SPEC_INDEX] = FX_SPECLIST_INDEX#LFO;
	
	effect[FX#NAME] = "LFO Modulator";
	
	state = effect + fx_list_headerlength;
	state[LFO_STATE#MOD_EFFECT(0)] = -1; // Initial target: note itself
	state[LFO_STATE#MOD_INDEX(1)] = 1; // Note amplitude
	// 2 was originally MOD_TYPE, but we can infer that
	
	state[LFO_STATE#FREQ(3)] = 5; // Freq
	state[LFO_STATE#AMP(4)] = 0.5; // Amp
);
effectspec[FX_HEADER#CONFIG_UI_FUNCTION] = {config_ui}effect_ui_lfo;
function effect_ui_lfo(effect) local(effect_index, target_effect, target_spec, mod_spec) (
	effect_index = (effect - fx_list_start)/fx_list_step;
	state = effect + fx_list_headerlength;
	ui_split_topratio(1/3);
		ui_push_heighttext(-1);
			ui_split_leftratio(0.2);
				ui_align(1, -1);
				ui_padright();
				ui_text("depth");
			ui_pop();
			ui_split_rightratio(0.2);
				ui_padleft();
				ui_align(0, -1);
				ui_textnumber(floor(state[LFO_STATE#AMP]*100 + 0.5), "%i%%");
			ui_pop();
			state[LFO_STATE#AMP] = control_hslider(state[LFO_STATE#AMP], 0, 1, 0);
		ui_pop();
	ui_split_next();
		ui_push_heighttext(-1);
			ui_split_leftratio(0.2);
				ui_padright();
				ui_align(1, -1);
				ui_text("frequency");
			ui_pop();
			ui_split_rightratio(0.2);
				ui_padleft();
				ui_align(0, -1);
				ui_textnumber(state[LFO_STATE#FREQ], "%.2fHz");
			ui_pop();
			state[LFO_STATE#FREQ] = control_hslider(state[LFO_STATE#FREQ], 0, 100, 3);
		ui_pop();
	ui_split_next();
		ui_push_heighttext(-1);
			ui_split_leftratio(0.2);
				ui_align(1, -1);
				ui_padright();
				ui_text("target");
			ui_pop();
			ui_split_rightratio(0.2);
				ui_padleft();
				ui_padright();
				control_button("edit") ? (
					ui_screen_open("automation-target");
					ui_screen_set(0, state + LFO_STATE#MOD_EFFECT);
					ui_screen_set(1, state + LFO_STATE#MOD_INDEX);
					ui_screen_set(2, state + LFO_STATE#AMP);
					ui_screen_set(3, effect_index);
				);
			ui_pop();
			ui_split_leftratio(0.6);
				ui_padright();
				state[LFO_STATE#MOD_EFFECT] < 0 ? (
					control_readout("Note");
				) : (
					target_effect = fx_list_start + fx_list_step*state[LFO_STATE#MOD_EFFECT];
					control_readout(target_effect[FX#NAME]);
				);
			ui_split_next();
				state[LFO_STATE#MOD_EFFECT] < 0 ? (
					control_readout(state[LFO_STATE#MOD_INDEX] == 0 ? "Frequency" : "Amplitude");
				) : (
					target_effect = fx_list_start + fx_list_step*state[LFO_STATE#MOD_EFFECT];
					target_spec = fx_spec_start + fx_spec_step*target_effect[FX#SPEC_INDEX];
					mod_spec = target_spec + fx_spec_headerlength + fx_spec_modlength*state[LFO_STATE#MOD_INDEX];
					control_readout(mod_spec[FX_MOD#NAME]);
				);
			ui_pop();
		ui_pop();
	ui_pop();
);
effectspec[FX_HEADER#CONFIG_SWAP_FUNCTION] = {config_swap}effect_swap_lfo;
function effect_swap_lfo(effect, fxIndex1, fxIndex2) (
	state = effect + fx_list_headerlength;

	state[LFO_STATE#MOD_EFFECT] == fxIndex1 ? (
		state[LFO_STATE#MOD_EFFECT] = fxIndex2;
	) : state[LFO_STATE#MOD_EFFECT] == fxIndex2 ? (
		state[LFO_STATE#MOD_EFFECT] = fxIndex1;
	);
	// TODO: make separate effect_delete handler for this - either that, or delete handler calls this
	state[LFO_STATE#MOD_EFFECT] < -1 ? (
		// Our target was just deleted - reset the effect
		effect_init_lfo(effect);
	);
);
effectspec[FX_HEADER#SETUP_NOTE_FUNCTION] = {note_setup}effect_note_setup_lfo;
function effect_note_setup_lfo(effect, note, notestate) local(state, targetIndex, targetModType, targetModRange, target_effect, target_mod) (
	state = effect + fx_list_headerlength;
	// Two modulatable parameters

	state[LFO_STATE#MOD_EFFECT] < 0 ? (
		state[LFO_STATE#MOD_INDEX] == 0 ? (
			targetIndex = NOTE#LOG_FREQ;
			targetModType = FX_MODTYPE#ADD;
			targetModRange = 1;
		) : (
			targetIndex = NOTE#AMP;
			targetModType = FX_MODTYPE#MULT;
			targetModRange = 1;
		);
	) : (
		target_effect = fx_list_start + fx_list_step*state[LFO_STATE#MOD_EFFECT];
		target_mod = fx_spec_start + fx_spec_headerlength + fx_spec_modlength*state[LFO_STATE#MOD_INDEX];
		
		targetModType = target_mod[FX_MOD#TYPE];
		targetModRange = target_mod[FX_MOD#RANGE];
		
		targetIndex = note_headerlength + note_fx_statelength*state[LFO_STATE#MOD_EFFECT] + state[LFO_STATE#MOD_INDEX];
	);

	notestate[LFO_NOTE_STATE#LOG_FREQ] = log(state[LFO_STATE#FREQ]); // freq
	notestate[LFO_NOTE_STATE#AMP] = state[LFO_STATE#AMP]; // amp
	
	// Use the remainder for private state
	notestate[LFO_NOTE_STATE#TARGET] = targetIndex;
	notestate[LFO_NOTE_STATE#MODTYPE] = targetModType;
	notestate[LFO_NOTE_STATE#PHASE] = 0; // Phase
);
effectspec[FX_HEADER#EXEC_NOTE_FUNCTION] = {note_exec}effect_note_exec_lfo;
function effect_note_exec_lfo(effect, note, notestate) local(angFreq, value, targetIndex) (
	targetIndex = notestate[LFO_NOTE_STATE#TARGET];
	targetIndex > 0 ? (
		angFreq = 2*$pi*exp(notestate[LFO_NOTE_STATE#LOG_FREQ(0)])*invsrate;
		notestate[LFO_NOTE_STATE#PHASE] += angFreq;
		value = notestate[LFO_NOTE_STATE#AMP]*sin(notestate[LFO_NOTE_STATE#PHASE]);
		notestate[LFO_NOTE_STATE#MODTYPE] == FX_MODTYPE#ADD ? (
			note[targetIndex] += value;
		) : (
			note[targetIndex] *= (1 + value);
		);
	);
);

function {effect_init}(effect_slot);
function {config_ui}(effect);
function {config_swap}(effect, index1, index2);
function {note_setup}(effect, note, notestate);
function {note_exec}(effect, note, notestate);

function append_effect(index) local(spec, effect, effect_name) (
	fx_list_count < fx_list_maxcount ? (
		// TODO: check the index is valid, otherwise insert placeholder (negative index)
		effect = fx_list_start + fx_list_step*fx_list_count;
		effect_name = string_fx_names_start + fx_list_count;
		spec = fx_spec_start + fx_spec_step*index;
		{effect_init:spec[FX_HEADER#FUNC_INIT]}(effect);

		// Make sure effect is using the correct mutable string slot
		effect[FX#NAME] != effect_name ? (
			strcpy(effect_name, effect[FX#NAME]);
			effect[FX#NAME] = effect_name;
		);
		
		clear_all_notes();
		fx_list_count += 1;
		clear_all_notes();

		fx_list_count - 1; // Index before increment
	) : -1;
);
function effect_swap(fxIndex1, fxIndex2) local(note, i, tmp, effect, effect2, spec) (
	// Swap the headers (copy the string values, don't swap references)
	effect = fx_list_start + fx_list_step*fxIndex1;
	effect2 = fx_list_start + fx_list_step*fxIndex2;
	strcpy(#effect_swap_tmp, effect[FX#NAME]);
	strcpy(effect[FX#NAME], effect2[FX#NAME]);
	strcpy(effect2[FX#NAME], #effect_swap_tmp);
	
	tmp = effect[FX#SPEC_INDEX];
	effect[FX#SPEC_INDEX] = effect2[FX#SPEC_INDEX];
	effect2[FX#SPEC_INDEX] = tmp;
	
	// Swap the states
	i = 0;
	while (i < fx_list_statelength) (
		tmp = (effect + fx_list_headerlength)[i];
		(effect + fx_list_headerlength)[i] = (effect2 + fx_list_headerlength)[i];
		(effect2 + fx_list_headerlength)[i] = tmp;
		i += 1;
	);

	i = 0;
	while (i < fx_list_count) (
		effect = fx_list_start + fx_list_step*i;
		spec = fx_spec_start + fx_spec_step*effect[FX#SPEC_INDEX];
		{config_swap:spec[FX_HEADER#CONFIG_SWAP_FUNCTION]}(effect, fxIndex1, fxIndex2);
		i += 1;
	);
	
	// Stop all notes, because their internal state is now in the wrong order
	clear_all_notes();
);

function reset_to_defaults() (
	action_recompute = 1;
	can_recompute = 1;
	has_set_parameters = 1;
	
	param_width_cents = 20;
	param_attack = 0.01;
	param_decay = 0.3;
	param_sustain = 0.75;
	param_release = 0.03;
	param_env_linear = 0;

	fx_list_count = 0;
	//append_effect(FX_SPECLIST_INDEX#LFO);
);
!has_set_parameters ? reset_to_defaults();

@block

action_recompute ? (
	can_recompute = 0;
	action_recompute = 0;
	recompute_index = 0;
);

recompute_index < wavetables_count ? (
	param_width = param_width_cents/1200*log(2);
	wavetable_index = recompute_index;
	recompute_stop_index = min(wavetables_count, recompute_index + recompute_chunk);
	while (
		ratio = (wavetable_index + 0.5)/wavetables_count;
		base_freq = exp(log(wavetable_low) + log(wavetable_high/wavetable_low)*ratio);
		// Zero it out
		i = 0;
		while (
			fftblock[i] = 0;
			i += 1;
			i < wavetable_sampleslength*2;
		);
		
		harmonic_range_factor = exp(param_width*2);
		i = 1;
		while (
			power = 0;
			indexfreq = i/wavetable_sampleslength*wavetable_refsrate;
			indexwidth = log((i + 1)/i);
			harmonic_freq = base_freq*floor(indexfreq/base_freq/harmonic_range_factor);
			end_freq = min(wavetable_maxfreq, indexfreq*harmonic_range_factor);
			while (
				harmonic_amp = 1/harmonic_freq;
				harmonic_power = harmonic_amp*harmonic_amp;
				log_width = max(indexwidth, param_width);
				hz_width = exp(log_width)*harmonic_freq;
				stddistance = log(indexfreq/harmonic_freq)*2/log_width;
				power += harmonic_power/hz_width*exp(-stddistance*stddistance); // Gaussian

				harmonic_freq += base_freq;
				harmonic_freq < end_freq;
			);
			amp = sqrt(power);
			phase1 = rand(2*$pi);
			//phase2 = rand(2*$pi);
			// Attempt to even out the mid-channel energy while still making the two channels uncorrelated
			phase2 = (rand() < 0.5) ? phase1 + $pi/2 : phase1 - $pi/2;
	
			leftR = amp*cos(phase1);
			leftI = amp*sin(phase1);
			rightR = amp*cos(phase2);
			rightI = amp*sin(phase2);
			
			0 ? ( // Mid/side decode
				mid = leftR;
				side = rightR;
				leftR = mid - side;
				rightR = mid + side;
				mid = leftI;
				side = rightI;
				leftI = mid - side;
				rightI = mid + side;
			);

			i2 = wavetable_sampleslength - i;
			fftblock[2*i] = leftR - rightI;
			fftblock[2*i + 1] = leftI + rightR;
			fftblock[2*i2] = leftR + rightI;
			fftblock[2*i2 + 1] = rightR - leftI;

			i += 1;
			i < wavetable_sampleslength/2;
		);
		
		// IFFT
		fft_ipermute(fftblock, 32768);
		ifft(fftblock, 32768);

		// Normalise
		sum2 = 0;
		maxabs = 0;
		i = 0;
		while (
			sum2 += fftblock[i]*fftblock[i];
			maxabs = max(maxabs, abs(fftblock[i]));
			i += 1;
			i < wavetable_sampleslength*2;
		);
		factor = 0.25/sqrt(sum2/(2*wavetable_sampleslength));

		// Place in wavetable
		wavetable = wavetables_start + wavetable_step*wavetable_index;
		wavetable[WAVETABLE#FREQ] = base_freq*srate/wavetable_refsrate;
		wavetable_samples = wavetable + wavetable_headerlength;
		assignedwavetable = wavetable;
		i = 0;
		while (
			wavetable_samples[i] = fftblock[i]*factor;
			i += 1;
			i < wavetable_sampleslength*2;
		);
		
		wavetable_index += 1;
		wavetable_index < recompute_stop_index;
	);
	recompute_index = wavetable_index;
);

midi_event = midirecv(midi_offset, midi_msg1, midi_msg23);
midi_event ? while (
	midisend(midi_offset, midi_msg1, midi_msg23); // passthrough
	midi_type = midi_msg1>>4;
	midi_channel = midi_msg1&0x0f;
	midi_msg2 = midi_msg23&$xff; // note / controller
	midi_msg3 = midi_msg23>>8; // velocity / value
	(midi_type == $x9 && midi_msg3 != 0) ? (
		// Note on
		note = notes_start;
		while (
			note[NOTE#ACTIVE] ? (
				note += notes_step;
				note < notes_end;
			);
			note[NOTE#ACTIVE] && note < notes_end;
		);
		// Found a free slot
		note < notes_end ? (
			// Note parameters
			note[NOTE#ACTIVE] = 1;
			note[NOTE#CHANNEL] = midi_channel;
			note[NOTE#NOTE] = midi_msg2;
			note[NOTE#VEL] = midi_msg3;
			note[NOTE#SECONDSFROMSTART] = -midi_offset*invsrate;
			note[NOTE#SECONDSFROMEND] = -note_maxduration;
			note[NOTE#LOG_FREQ_BASE] = log(440*pow(2, (note[NOTE#NOTE] - 69)/12));
			note[NOTE#AMP_BASE] = volume*note[NOTE#VEL]/127;
			
			// Wavetable params
			wavetable_index = (note[NOTE#LOG_FREQ_BASE] - log(wavetable_low))/log(wavetable_high/wavetable_low)*wavetables_count;
			wavetable_index = min(wavetables_count - 1, max(0, floor(wavetable_index)));
			note[NOTE#WAVEINDEX] = wavetable_index; // Wavetable #0
			note[NOTE#SAMPLEPOS] = rand(wavetable_sampleslength);
			display_wavetable_index = wavetable_index;
			
			// FX note setup
			i = 0;
			i < fx_list_count ? while (
				effect = fx_list_start + i*fx_list_step;
				spec = fx_spec_start + fx_spec_step*effect[FX#SPEC_INDEX];
				notestate = note + note_headerlength + note_fx_statelength*i;

				{note_setup:spec[FX_HEADER#SETUP_NOTE_FUNCTION]}(effect, note, notestate);

				i += 1;
				i < fx_list_count;
			);
		);
	) : (midi_type == $x8 || (midi_type == $x9 && midi_msg3 == 0)) ? (
		// Note off 
		note = notes_start;
		while (
			note[NOTE#ACTIVE] && note[NOTE#CHANNEL] == midi_channel && note[NOTE#NOTE] == midi_msg2 ? (
				note[NOTE#SECONDSFROMEND] = max(note[NOTE#SECONDSFROMEND], -midi_offset*invsrate);
			);
			note += notes_step;
			note < notes_end;
		);
	);
	
	midi_event = midirecv(midi_offset, midi_msg1, midi_msg23);
);

polyphony_current = 0;
note = notes_start;
note_active_end = notes_start;
while (
	note[NOTE_ACTIVE] ? (
		polyphony_current += 1;
		note_active_end = note + notes_step;
	);
	note += notes_step;
	note < notes_end;
);

@sample

note = notes_start;
while (
	note[NOTE#ACTIVE] ? (
		note[NOTE#SECONDSFROMSTART] > 0 ? (
			secondsFromStart = note[NOTE#SECONDSFROMSTART];
			secondsFromEnd = note[NOTE#SECONDSFROMEND];
			note[NOTE#LOG_FREQ] = note[NOTE#LOG_FREQ_BASE];
			note[NOTE#AMP] = note[NOTE#AMP_BASE];
			
			// FX note setup
			i = 0;
			i < fx_list_count ? while (
				effect = fx_list_start + i*fx_list_step;
				spec = fx_spec_start + fx_spec_step*effect[FX#SPEC_INDEX];
				notestate = note + note_headerlength + note_fx_statelength*i;

				{note_exec:spec[FX_HEADER#EXEC_NOTE_FUNCTION]}(effect, note, notestate);
				i += 1;
				i < fx_list_count;
			);

			env = 1;
			stretch = param_env_linear ? 1 : 1;
			attack = param_attack;
			decay = param_decay*stretch;
			sustain = param_sustain;
			release = param_release*stretch;

			secondsFromStart < attack ? (
				env *= secondsFromStart/attack;
			) : (
				secondsFromAttack = secondsFromStart - attack;
				secondsFromAttack < decay ? (
					env *= sustain + (1 - sustain)*(
						param_env_linear
							? 1 - secondsFromAttack/decay
							: pow(1 - secondsFromAttack/decay, 3)
					);
				) : (
					env *= sustain;
				);
			);
			secondsFromEnd > 0 ? (
				secondsFromEnd > release ? (
					env = 0;
					note[NOTE#ACTIVE] = 0;
				) : (
					env *= param_env_linear
						? 1 - secondsFromEnd/release
						: pow(1 - secondsFromEnd/release, 3);
				);
			);
			note[NOTE#AMP] *= env;
			
			wavetable = wavetables_start + note[NOTE#WAVEINDEX]*wavetable_step;
			wavetable_samples = wavetable + wavetable_headerlength;
			midsample = note[NOTE#SAMPLEPOS];
			lowsample = floor(midsample);
			highsample = ceil(midsample)%wavetable_sampleslength;
			ratio = (midsample - lowsample);

			lowvalue = wavetable_samples[2*lowsample];
			highvalue = wavetable_samples[2*highsample];
			midvalueL = lowvalue + (highvalue - lowvalue)*ratio;

			lowvalue = wavetable_samples[2*lowsample + 1];
			highvalue = wavetable_samples[2*highsample + 1];
			midvalueR = lowvalue + (highvalue - lowvalue)*ratio;
			
			wavetable_freq = wavetable[WAVETABLE#FREQ];
			freqRatio = exp(note[NOTE#LOG_FREQ])/wavetable_freq;

			midsample += freqRatio;
			midsample > wavetable_sampleslength ? while (
				midsample -= wavetable_sampleslength;
				midsample > wavetable_sampleslength;
			);
			note[NOTE#SAMPLEPOS] = midsample;
			
			spl0 += midvalueL*note[NOTE#AMP];
			spl1 += midvalueR*note[NOTE#AMP];
		);

		note[NOTE#SECONDSFROMSTART] += invsrate;
		note[NOTE#SECONDSFROMEND] += invsrate;
	);
	note += notes_step;
	note < note_active_end;
);

@gfx

function draw_waveform() local(wavetable, samples, value, x, y, gi, gis, box_left, box_top, box_width, box_height) (
	box_left = ui_left();
	box_top = ui_top();
	box_width = ui_width();
	box_height = ui_height();

	wavetable = wavetables_start + display_wavetable_index*wavetable_step;
	samples = wavetable + wavetable_headerlength;
	gis = ceil(wavetable_sampleslength*0.25/box_width);
	// Left - blue
	gi = 0;
	gfx_r = 0.25;
	gfx_g = 0.5;
	gfx_b = 0.75;
	gfx_x = box_left;
	gfx_y = ui_top() + box_height/2;
	while (
		value = min(1, max(-1, samples[gi*2]));
		x = box_left + gi/wavetable_sampleslength*box_width;
		y = box_top + 0.5*(1 - value)*box_height;
		gfx_lineto(x, y, 0);
		gi += 1;
		gi < wavetable_sampleslength;
	);
	// Right - orange
	gi = 0;
	gfx_r = 0.75;
	gfx_g = 0.5;
	gfx_b = 0.25;
	gfx_x = box_left;
	gfx_y = box_top + box_height/2;
	while (
		value = min(1, max(-1, samples[gi*2 + 1]));
		x = box_left + gi/wavetable_sampleslength*box_width;
		y = box_top + 0.5*(1 - value)*box_height;
		gfx_lineto(x, y, 0);
		gi += 1;
		gi < wavetable_sampleslength;
	);
	ui_color(0, 0, 0);
	ui_border();
);

ui_start("main"); // Default screen

slider_value = slider_value ? slider_value : 0.5;

ui_screen() == "main" ? (
	control_navbar("PadSynth", "About", "about");
	ui_pad();
	ui_split_toptext("");
		ui_split_leftratio(0.5);
			control_button("Envelope (ADSR)") ? (
				ui_screen_open("envelope");
			);
		ui_split_next();
			display_first_effect = fx_list_start;
			control_button("Effects") ? (
				ui_screen_open("list-effects");
			);
		ui_pop();
	ui_pop();
	ui_padtop();
	
	ui_split_bottomtext("");
		ui_split_righttext("Regenerate");
			control_indicator_button("Regenerate", can_recompute) ? (
				can_recompute ? action_recompute = 1;
			);
		ui_pop();
	
		ui_split_lefttext("Width (cents)");
			ui_text("Width (cents)");
		ui_pop();
		ui_split_righttext("200");
			ui_padleft();
			ui_align(0, -1);
			ui_textnumber(param_width_cents + 0.5, "%i");
		ui_pop();

		new_width_cents = control_hslider(param_width_cents, 5, 200, 3);
		new_width_cents != param_width_cents ? can_recompute = 1;
		param_width_cents = new_width_cents;
	ui_pop();
	ui_padbottom();
	
	ui_push();
		ui_color(0, 0, 0);
		ui_fill();
		draw_waveform();
		control_finish_enabled(1);
	ui_pop();
) : ui_screen() == "about" ? (
	control_navbar("About", -1, -1);
	
	ui_pad();

	ui_align(0.5, 0.67);
	text_height = ui_wraptext("This is a JSFX implementation of the 'padsynth' algorithm from ZynAddSubFX, which I love but hasn\'t been updated in a while.  It\'s not an exact replacement, but I\'m adding features as I need them.\n\nIt\'s a sample-based synth, where the samples are designed in the frequency domain (which allows customised harmonic spread) and then generated using an inverse FFT.\n\nThe GUI for this synth uses a JSFX UI library originally written for this synth, but is now a project of its own.");
	
	ui_push_above(text_height);
		ui_align(0.5, 0.5);
		ui_fontsize(20);
		ui_fontbold(1);
		ui_text("PadSynth");
		ui_push_belowtext("PadSynth");
			ui_fontsize(0);
			ui_fontbold(0);
			ui_fontitalic(1);
			ui_align(0.5, 0);
			ui_text("by Geraint Luff");
		ui_pop();
	ui_pop();
) : ui_screen() == "envelope" ? (
	control_navbar("Envelope (ADSR)", -1, -1);
	ui_split_topratio(1/5);
		ui_push_heighttext(-1);
			ui_split_leftratio(0.2);
				ui_padright();
				ui_align(1, -1);
				ui_text("Attack");
			ui_pop();
			ui_split_rightratio(0.2);
				ui_padleft();
				ui_align(0, -1);
				ui_textnumber(floor(param_attack*1000 + 0.5), "%ims");
			ui_pop();
			param_attack = control_hslider(param_attack, 0.001, 1.5, 3);
		ui_pop();
	ui_split_next();
		ui_push_heighttext(-1);
			ui_split_leftratio(0.2);
				ui_padright();
				ui_align(1, -1);
				ui_text("Decay");
			ui_pop();
			ui_split_rightratio(0.2);
				ui_padleft();
				ui_align(0, -1);
				ui_textnumber(floor(param_decay*1000 + 0.5), "%ims");
			ui_pop();
			param_decay = control_hslider(param_decay, 0.001, 5, 3);
		ui_pop();
	ui_split_next();
		ui_push_heighttext(-1);
			ui_split_leftratio(0.2);
				ui_padright();
				ui_align(1, -1);
				ui_text("Sustain");
			ui_pop();
			ui_split_rightratio(0.2);
				ui_padleft();
				ui_align(0, -1);
				ui_textnumber(floor(param_sustain*100 + 0.5), "%i%%");
			ui_pop();
			param_sustain = control_hslider(param_sustain, 0, 1, 0);
		ui_pop();
	ui_split_next();
		ui_push_heighttext(-1);
			ui_split_leftratio(0.2);
				ui_padright();
				ui_align(1, -1);
				ui_text("Release");
			ui_pop();
			ui_split_rightratio(0.2);
				ui_padleft();
				ui_align(0, -1);
				ui_textnumber(floor(param_release*1000 + 0.5), "%ims");
			ui_pop();
			param_release = control_hslider(param_release, 0.005, 5, 3);
		ui_pop();
	ui_split_next();
		ui_push_heighttext(-1);
			ui_split_leftratio(0.2);
				ui_padright();
				ui_align(1, -1);
				ui_text("Curve");
			ui_pop();
			ui_split_rightratio(0.2);
			ui_pop();
			
			ui_align(0, -1); // Align left
			param_env_linear = control_selector(param_env_linear, param_env_linear ? "Linear" : "Tapered", !param_env_linear, !param_env_linear);
		ui_pop();
	ui_pop();
) : ui_screen() == "list-effects" ? (
	g_effect_index = 0;
	control_navbar("", -1, -1);
	ui_split_bottomtext(-1);
		control_indicator_button("add effect", fx_list_count < fx_list_maxcount) ? (
			fx_list_count < fx_list_maxcount ? ui_screen_open("add-effect");
		);
	ui_pop();

	// Mouse-up applies to whole list, and comes first - otherwise when dragging downwards, the source index gets cleared before we get to dropped one
	ui_mouse_up() && g_drageffect_index >= 0 && g_drageffect_targetindex >= 0 ? (
		while (g_drageffect_targetindex > g_drageffect_index) (
			effect_swap(g_drageffect_index, g_drageffect_index + 1);
			g_drageffect_index += 1;
		);
		while (g_drageffect_targetindex < g_drageffect_index) (
			effect_swap(g_drageffect_index, g_drageffect_index - 1);
			g_drageffect_index -= 1;
		);
		g_drageffect_index = -1;
	);
	
	ui_split_topratio(1/fx_list_maxcount);
	while (g_effect_index < fx_list_maxcount) (
		g_effect_index < fx_list_count ? (
			g_effect = fx_list_start + fx_list_step*g_effect_index;
			g_effect_spec = fx_spec_start += fx_spec_step*g_effect[FX#SPEC_INDEX];
			ui_color(0, 0, 0);
			ui_split_rightratio(0.15) ? (
				control_button("edit") ? (
					ui_screen_open("edit-effect");
					ui_screen_set(0, g_effect);
				);
			);
			ui_pop();
			
			// Double-click to edit name
			ui_click() && ui_clickcount() == 2 ? (
				ui_screen_open("control.prompt");
				ui_screen_set(0, g_effect[FX#NAME]);
				ui_screen_set(1, "Rename effect");
			);
			
			// Drag to re-order
			ui_drag() ? (
				g_drageffect_index = g_effect_index;
			) : (
				g_drageffect_index == g_effect_index ? (
					g_drageffect_index = -1;
				);
			);
			// Drop to re-order
			ui_hover() && g_drageffect_index >= 0 ? (
				g_drageffect_targetindex = g_effect_index;
				g_effect_index < g_drageffect_index ? (
					ui_mouse_yratio() < 0.5 ? (
						g_drageffect_targetindex = g_effect_index;
					) : (
						g_drageffect_targetindex = g_effect_index + 1;
					);
				) : g_effect_index > g_drageffect_index ? (
					ui_mouse_yratio() < 0.5 ? (
						g_drageffect_targetindex = g_effect_index - 1;
					) : (
						g_drageffect_targetindex = g_effect_index;
					);
				);
			);
			
			strlen(g_effect[FX#NAME]) == 0 ? (
				strcpy(g_effect[FX#NAME], g_effect_spec[FX_HEADER#NAME]);
			);
			g_drageffect_index == g_effect_index ? (
				ui_color(160, 160, 160);
				ui_fill();
				ui_color(255, 255, 255);
				ui_text(g_effect[FX#NAME]);
			) : (
				(g_effect_index%2) ? (
					ui_colora(255, 255, 255, 1);
					ui_fill();
				);
				ui_color(0, 0, 0);
				ui_text(g_effect[FX#NAME]);
			);
			
			ui_color(0, 0, 0);
			ui_hover() && g_drageffect_index >= 0 ? (
				ui_mouse_yratio() < 0.5 ? (
					ui_border_top();
				) : (
					ui_border_bottom();
				);
			);

			ui_colora(0, 0, 0, 0.1);
			ui_border_bottom();
		);

		g_effect_index += 1;
		ui_split_next();
	);
	ui_pop();
) : ui_screen() == "automation-target" ? (
	control_dialog("Select effect", 0, 0, -1, "cancel");
	g_arg_effect = ui_screen_get(0);
	g_arg_index = ui_screen_get(1);
	g_arg_range = ui_screen_get(2);
	g_arg_minIndex = ui_screen_get(3);

	g_element_height = min(ui_texth() + ui_vpadding()*2, ui_height()/(fx_list_count + 1));
	ui_split_top(g_element_height);
		ui_hover() ? (
			control_button("Note");
		) : (
			ui_color(255, 255, 255);
			ui_fill();
			ui_color(0, 0, 0);
			ui_text("Note");
			ui_colora(0, 0, 0, 0.1);
			ui_border_bottom();
		);
		ui_click() ? (
			ui_screen_close("automation-target");
			ui_screen_open("automation-target-index");
			ui_screen_set(0, g_arg_effect);
			ui_screen_set(1, g_arg_index);
			ui_screen_set(2, g_arg_range);
			ui_screen_set(3, -1);
		);
	ui_split_next();
		gi = 0;
		while (gi < fx_list_count) (
			g_effect = fx_list_start + fx_list_step*gi;
			
			(gi <= g_arg_minIndex) ? (
				ui_color(224, 224, 224);
				ui_fill();
				ui_color(180, 180, 180);
				ui_text(g_effect[FX#NAME]);
			) : (
				ui_hover() ? (
					control_button(g_effect[FX#NAME]);
				) : (
					ui_color(255, 255, 255);
					ui_fill();
					ui_color(0, 0, 0);
					ui_text(g_effect[FX#NAME]);
					ui_colora(0, 0, 0, 0.1);
					ui_border_bottom();
				);
				
				ui_click() ? (
					ui_screen_close("automation-target");
					ui_screen_open("automation-target-index");
					ui_screen_set(0, g_arg_effect);
					ui_screen_set(1, g_arg_index);
					ui_screen_set(2, g_arg_range);
					ui_screen_set(3, gi);
				);
			);
		
			ui_split_next();
			gi += 1;
		);
	ui_pop();
) : ui_screen() == "automation-target-index" ? (
	control_dialog("Select parameter", 0, 0, -1, "cancel");
	g_arg_effect = ui_screen_get(0);
	g_arg_index = ui_screen_get(1);
	g_arg_range = ui_screen_get(2);
	g_effect_index = ui_screen_get(3);

	g_effect_index >= 0 ? (
		g_effect = fx_list_start + fx_list_step*g_effect_index;
		g_effect_spec = fx_spec_start + fx_spec_step*g_effect[FX#SPEC_INDEX];
		g_effect_modcount = g_effect_spec[FX_HEADER#MODCOUNT];
	) : (
		g_effect_modcount = 2;
	);
	
	g_element_height = min(ui_texth() + ui_vpadding()*2, ui_height()/max(1, g_effect_modcount));
	ui_split_top(g_element_height);
		gi = 0;
		while (gi < g_effect_modcount) (
			g_effect_index >= 0 ? (
				g_mod_spec = g_effect_spec + fx_spec_headerlength + fx_spec_modlength*gi;
				g_mod_name = g_mod_spec[FX_MOD#NAME]; 
				g_mod_range = g_mod_spec[FX_MOD#RANGE];
			) : (
				g_mod_name = (gi == 0) ? "Frequency" : "Amplitude";
				g_mod_range = (gi == 0) ? 0.1 : 1;
			);
			
			ui_hover() ? (
				control_button(g_mod_name);
			) : (
				ui_color(255, 255, 255);
				ui_fill();
				ui_color(0, 0, 0);
				ui_text(g_mod_name);
				ui_colora(0, 0, 0, 0.1);
				ui_border_bottom();
			);
			
			ui_click() ? (
				g_arg_effect[0] = g_effect_index;
				g_arg_index[0] = gi;
				g_arg_range[0] = 
				ui_screen_close("automation-target-index");
			);
		
			ui_split_next();
			gi += 1;
		);
	ui_pop();
) : ui_screen() == "add-effect" ? (
	append_effect(FX_SPECLIST_INDEX#LFO);
	ui_screen_close();
) : ui_screen() == "edit-effect" ? (
	g_effect = ui_screen_get(0);
	g_effect_spec = fx_spec_start + fx_spec_step*g_effect[FX#SPEC_INDEX];

	control_navbar(g_effect[FX#NAME], -1, -1);
	effect_ui = g_effect_spec[FX_HEADER#CONFIG_UI_FUNCTION];
	{config_ui:effect_ui}(g_effect);
) : control_system();

@serialize

// Serialisation is a sequence of (id, length, value).  All unrecognised IDs (currently) result in an error.
// We do our own string serialisation so that we can keep track of the length.
// The VAR_ID enum values should always force a value

function read_plain_var() local(var_length, value) (
	file_var(0, var_length);
	var_length ? while(
		file_var(0, value);
		var_length -= 1;
		var_length;
	);
	value;
);
function read_string_var(string) local(vars_read, char_count, char, string_length) (
	strcpy(string, "");
	string_length = 0;
	file_var(0, char_count);
	vars_read = 1 + char_count;
	string_length < char_count ? while (
		file_var(0, char);
		str_setchar(string, string_length, char);
		string_length += 1;
		string_length < char_count;
	);
	vars_read;
);
function read_effect() local(read_length, effect, effect_index, spec_index, var_id, i, var_length, value) (
	fx_list_count < fx_list_maxcount ? (
		file_var(0, read_length);
		
		file_var(0, spec_index);
		read_length -= 1;
		// TODO: check that the effect is a known type, otherwise put a placeholder in so the indices don't get screwed up (and remove placeholders at the end)
		
		effect_index = append_effect(spec_index);
		effect = fx_list_start + fx_list_step*effect_index;
		
		read_length > 0 ? while(
			file_var(0, var_id);
			read_length -= 1;
			var_id == VAR_ID#effect_name(104) ? (
				// Point it at the correct mutable string slot
				effect[FX#NAME] = string_fx_names_start + effect_index;
				// Read the variable into that slot
				read_length -= read_string_var(effect[FX#NAME]);
			) : var_id == VAR_ID#effect_state(105) && effect >= 0 ? (
				file_var(0, var_length);
				read_length -= var_length + 1;
				effectstate = effect + fx_list_headerlength;
				i = 0;
				i < var_length ? while (
					file_var(0, value);
					effectstate[i] = value;
					i += 1;
					i < var_length;
				);
			) : (
				sprintf(#read_effect_error, "Unrecognised ID in effect: %f", var_id);
				ui_error(#read_effect_error);
				// Consume the data so we don't get out-of-sync and screw up the rest of the config in a potentially painful way
				file_var(0, var_length);
				read_length -= var_length + 1;
				var_length > 0 ? while (
					file_var(0, i);
					var_length -= 1;
					var_length > 0;
				);
			);
			read_length > 0;
		);
	) : (
		read_plain_var();
	);
);
function read_var() local(var_id, i, effect) (
	file_var(0, var_id);
	var_id == VAR_ID#param_width_cents(1) ? (
		param_width_cents = read_plain_var();
	) : var_id == VAR_ID#param_env_linear(99) ? (
		param_env_linear = read_plain_var();
	) : var_id == VAR_ID#param_attack(100) ? (
		param_attack = read_plain_var();
	) : var_id == VAR_ID#param_decay(101) ? (
		param_decay = read_plain_var();
	) : var_id == VAR_ID#param_sustain(102) ? (
		param_sustain = read_plain_var();
	) : var_id == VAR_ID#param_release(103) ? (
		param_release = read_plain_var();
	) : var_id == VAR_ID#effect(106) ? (
		read_effect();
	) : (
		ui_error("Unrecognised variable in state");
		read_plain_var();
	);
);
function write_plain_var(var_id, value) local(length) (
	length = 1;
	file_var(0, var_id);
	file_var(0, length);
	file_var(0, value);
);
function write_string_var(var_id, string) local(string_length, i, char) (
	file_var(0, var_id);
	string_length = strlen(string);
	file_var(0, string_length);
	i = 0;
	i < string_length ? while(
		char = str_getchar(string, i);
		file_var(0, char);
		i += 1;
		i < string_length;
	);
);
function write_buffer_var(var_id, buffer, length) local(i, value) (
	file_var(0, var_id);
	file_var(0, length);
	i = 0;
	i < length ? while(
		value = buffer[i];
		file_var(0, value);
		i += 1;
		i < length;
	);
);
function write_effects() local(i, effect, var_id, var_length) (
	i = 0;
	i < fx_list_count ? while(
		effect = fx_list_start + fx_list_step*i;

		var_id = VAR_ID#effect(106);
		var_length = 1; // Index
		var_length += 2 + strlen(effect[FX#NAME]);
		var_length += 2 + fx_list_statelength;
		
		file_var(0, var_id);
		file_var(0, var_length);
		
		file_var(0, effect[FX#SPEC_INDEX]);
		write_string_var(VAR_ID#effect_name(104), effect[FX#NAME]);
		write_buffer_var(VAR_ID#effect_state(105), effect + fx_list_headerlength, fx_list_statelength);
		
		i += 1;
		i < fx_list_count;
	);
);

// Actual logic
file_avail(0) >= 0 ? (
	reset_to_defaults();
	file_avail(0) ? (
		fx_list_count = 0;
		while (
			read_var();
			file_avail(0);
		);
	);
	clear_all_notes();
	action_recompute = 1;
) : (
	write_plain_var(VAR_ID#param_width_cents(1), param_width_cents);
	write_plain_var(VAR_ID#param_attack(100), param_attack);
	write_plain_var(VAR_ID#param_decay(101), param_decay);
	write_plain_var(VAR_ID#param_sustain(102), param_sustain);
	write_plain_var(VAR_ID#param_release(103), param_release);
	write_plain_var(VAR_ID#param_env_linear(99), param_env_linear);
	write_effects();
);