desc:new effect
in_pin:none;
out_pin:Left
out_pin:Right

@init
can_recompute = 0;
action_recompute = 0;
// recompute_index - zero initially;
recompute_chunk = 10000;
polyphony = 64;

fftblock = 0;
fftblock_end = 65536;

screen_stack = fftblock_end;
screen_count = 10;
screen_step = 10;
screen_stack_end = screen_stack + screen_count*screen_step;

note_fx_start = screen_stack_end;
note_fx_count = 10;
fx_headerlength = 3; // Type, name, N-mod
fx_modspeclength = 3;
FX_MOD_TYPE = 0;
FX_MOD_RANGE = 1;
FX_MOD_DESC = 2;
fx_statelength = 32; // first N are modulatable parameters, the rest is internal state
note_fx_step = fx_headerlength + fx_statelength;
note_fx_end = note_fx_start + note_fx_step*note_fx_count;

notes_start = note_fx_end;
N_ACTIVE = 0;
N_CHANNEL = 1;
N_NOTE = 2;
N_VEL = 3;
N_SAMPLESFROMSTART = 4;
N_SAMPLESFROMEND = 5;
N_FREQ = 6;
N_AMP = 7;
N_WAVEINDEX = 8;
N_SAMPLEPOS = 9;

notes_step = 32;
notes_end = notes_start + polyphony*notes_step;
// Clear all notes
note = notes_start;
while (
	note[0] = 0;
	note += notes_step;
	note < notes_end;
);

wavetables_start = notes_end;
wavetables_count = 18;
wavetable_sampleslength = 32768;
wavetable_headerlength = 1; // Freq
wavetable_step = wavetable_headerlength + wavetable_sampleslength*2;
wavetables_end = wavetables_start + wavetables_count*wavetable_step;

display_wavetable_index = floor(wavetables_count/2);

volume_db = -12;
volume = pow(10, volume_db/20);
note_maxduration = srate*60*60*24*365;

wavetable_maxfreq = 18000;
wavetable_refsrate = 48000;
// 6+ octaves, centred on 440
wavetable_low = 50;
wavetable_high = 4000;

FX_ID_ADSR = 1;
function effect_init_adsr(effect) local(mods) (
	effect[0] = FX_ID_ADSR;
	effect[1] = "Envelope (ADSR)";
	effect[2] = 0; // No modulatable parameters - TODO: add a 'stretch' in here, at least for decay

	state = effect + fx_headerlength;
	state[0] = 0.01; // Attack
	state[1] = 0.3; // Decay
	state[2] = 0.75; // Sustain
	state[3] = 0.03; // Release
	state[4] = 0; // Linear
);

function reset_to_defaults() local(i, note_effect) (
	action_recompute = 1;
	has_set_parameters = 1;
	
	param_width_cents = 20;
	param_attack = 0.01;
	param_decay = 0.3;
	param_sustain = 0.75;
	param_release = 0.03;
	param_env_linear = 0;
	
	i = 0;
	while (
		note_effect = note_fx_start + i*note_fx_step;
		note_effect[0] = 0; // Disabled
		i < note_fx_count;
	);
	note_effect = note_fx_start; // First slot
	effect_init_adsr(note_effect);
);
!has_set_parameters ? reset_to_defaults();

function log_to_slider(value, low, high) (
	log(value/low)/log(high/low);
);
function slider_to_log(value, low, high) (
	exp(log(low) + log(high/low)*value);
);
function range_to_slider(value, low, high) (
	(value - low)/(high - low);
);
function slider_to_range(value, low, high) (
	low + (high - low)*value;
);
function power_to_slider(value, low, high, power) (
	pow((value - low)/(high - low), 1/power);
);
function slider_to_power(value, low, high, power) (
	low + (high - low)*pow(value, power);
);

@block

action_recompute ? (
	can_recompute = 0;
	action_recompute = 0;
	recompute_index = 0;
);

recompute_index < wavetables_count ? (
	param_width = param_width_cents/1200*log(2);
	wavetable_index = recompute_index;
	recompute_stop_index = min(wavetables_count, recompute_index + recompute_chunk);
	while (
		ratio = (wavetable_index + 0.5)/wavetables_count;
		base_freq = exp(log(wavetable_low) + log(wavetable_high/wavetable_low)*ratio);
		// Zero it out
		i = 0;
		while (
			fftblock[i] = 0;
			i += 1;
			i < wavetable_sampleslength*2;
		);
		
		harmonic_range_factor = exp(param_width*2);
		i = 1;
		while (
			power = 0;
			indexfreq = i/wavetable_sampleslength*wavetable_refsrate;
			indexwidth = log((i + 1)/i);
			harmonic_freq = base_freq*floor(indexfreq/base_freq/harmonic_range_factor);
			end_freq = min(wavetable_maxfreq, indexfreq*harmonic_range_factor);
			while (
				harmonic_amp = 1/harmonic_freq;
				harmonic_power = harmonic_amp*harmonic_amp;
				log_width = max(indexwidth, param_width);
				hz_width = exp(log_width)*harmonic_freq;
				stddistance = log(indexfreq/harmonic_freq)*2/log_width;
				power += harmonic_power/hz_width*exp(-stddistance*stddistance); // Gaussian

				harmonic_freq += base_freq;
				harmonic_freq < end_freq;
			);
			amp = sqrt(power);
			phase1 = rand(2*$pi);
			//phase2 = rand(2*$pi);
			// Attempt to even out the mid-channel energy while still making the two channels uncorrelated
			phase2 = (rand() < 0.5) ? phase1 + $pi/2 : phase1 - $pi/2;
	
			leftR = amp*cos(phase1);
			leftI = amp*sin(phase1);
			rightR = amp*cos(phase2);
			rightI = amp*sin(phase2);
			
			0 ? ( // Mid/side decode
				mid = leftR;
				side = rightR;
				leftR = mid - side;
				rightR = mid + side;
				mid = leftI;
				side = rightI;
				leftI = mid - side;
				rightI = mid + side;
			);

			i2 = wavetable_sampleslength - i;
			fftblock[2*i] = leftR - rightI;
			fftblock[2*i + 1] = leftI + rightR;
			fftblock[2*i2] = leftR + rightI;
			fftblock[2*i2 + 1] = rightR - leftI;

			i += 1;
			i < wavetable_sampleslength/2;
		);
		
		// IFFT
		fft_ipermute(fftblock, 32768);
		ifft(fftblock, 32768);

		// Normalise
		sum2 = 0;
		maxabs = 0;
		i = 0;
		while (
			sum2 += fftblock[i]*fftblock[i];
			maxabs = max(maxabs, abs(fftblock[i]));
			i += 1;
			i < wavetable_sampleslength*2;
		);
		factor = 0.25/sqrt(sum2/(2*wavetable_sampleslength));

		// Place in wavetable
		wavetable = wavetables_start + wavetable_step*wavetable_index;
		wavetable[0] = base_freq*srate/wavetable_refsrate;
		wavetable_samples = wavetable + wavetable_headerlength;
		assignedwavetable = wavetable;
		i = 0;
		while (
			wavetable_samples[i] = fftblock[i]*factor;
			i += 1;
			i < wavetable_sampleslength*2;
		);
		first = fftblock[0];
		first2 = wavetable_samples[0];
		
		wavetable_index += 1;
		wavetable_index < recompute_stop_index;
	);
	recompute_index = wavetable_index;
);

midi_event = midirecv(midi_offset, midi_msg1, midi_msg23);
midi_event ? while (
	midisend(midi_offset, midi_msg1, midi_msg23); // passthrough
	midi_type = midi_msg1>>4;
	midi_channel = midi_msg1&0x0f;
	midi_msg2 = midi_msg23&$xff; // note / controller
	midi_msg3 = midi_msg23>>8; // velocity / value
	(midi_type == $x9 && midi_msg3 != 0) ? (
		// Note on
		note = notes_start;
		while (
			note[0] ? (
				note += notes_step;
				note < notes_end;
			);
			note[0] && note < notes_end;
		);
		// Found a free slot
		note < notes_end ? (
			// Note parameters
			note[0] = 1;
			note[N_CHANNEL] = midi_channel;
			note[N_NOTE] = midi_msg2;
			note[N_VEL] = midi_msg3;
			note[N_SAMPLESFROMSTART] = midi_offset;
			note[N_SAMPLESFROMEND] = -note_maxduration;
			note[N_FREQ] = 440*pow(2, (midi_msg2 - 69)/12);
			note[N_AMP] = volume*midi_msg3/127;
			
			// Wavetable params
			wavetable_index = log(note[N_FREQ]/wavetable_low)/log(wavetable_high/wavetable_low)*wavetables_count;
			wavetable_index = min(wavetables_count - 1, max(0, floor(wavetable_index)));
			note[N_WAVEINDEX] = wavetable_index; // Wavetable #0
			note[N_SAMPLEPOS] = rand(wavetable_sampleslength);
			display_wavetable_index = wavetable_index;
		);
	) : (midi_type == $x8 || (midi_type == $x9 && midi_msg3 == 0)) ? (
		// Note off 
		note = notes_start;
		while (
			note[0] && note[N_CHANNEL] == midi_channel && note[N_NOTE] == midi_msg2 ? (
				note[N_SAMPLESFROMEND] = max(note[N_SAMPLESFROMEND], -midi_offset);
			);
			note += notes_step;
			note < notes_end;
		);
	);
	
	midi_event = midirecv(midi_offset, midi_msg1, midi_msg23);
);

polyphony_current = 0;
note = notes_start;
note_active_end = notes_start;
while (
	note[0] ? (
		polyphony_current += 1;
		note_active_end = note + notes_step;
	);
	note += notes_step;
	note < notes_end;
);

@sample

note = notes_start;
while (
	note[0] ? (
		note[N_SAMPLESFROMSTART] > 0 ? (
			secondsFromStart = note[N_SAMPLESFROMSTART]/srate;
			secondsFromEnd = note[N_SAMPLESFROMEND]/srate;
			note_freq = note[N_FREQ];
			env = 1;
			
			stretch = param_env_linear ? 1 : 2;
			attack = param_attack;
			decay = param_decay*stretch;
			sustain = param_sustain;
			release = param_release*stretch;

			secondsFromStart < attack ? (
				env *= secondsFromStart/attack;
			) : (
				secondsFromAttack = secondsFromStart - attack;
				secondsFromAttack < decay ? (
					env *= 1 - (1 - sustain)*secondsFromAttack/decay;
				) : (
					env *= sustain;
				);
			);
			secondsFromEnd > 0 ? (
				secondsFromEnd > release ? (
					env = 0;
					note[0] = 0;
				) : (
					env *= 1 - secondsFromEnd/release;
				);
			);
			
			!param_env_linear ? env = env*env*env;
			
			amp = env*note[N_AMP];
			
			wavetable = wavetables_start + note[N_WAVEINDEX]*wavetable_step;
			wavetable_samples = wavetable + wavetable_headerlength;
			midsample = note[N_SAMPLEPOS];
			lowsample = floor(midsample);
			highsample = ceil(midsample)%wavetable_sampleslength;
			ratio = (midsample - lowsample);

			lowvalueL = wavetable_samples[2*lowsample];
			lowvalueR = wavetable_samples[2*lowsample + 1];
			highvalueL = wavetable_samples[2*highsample];
			highvalueR = wavetable_samples[2*highsample + 1];
			midvalueL = lowvalueL + (highvalueL - lowvalueL)*ratio;
			midvalueR = lowvalueR + (highvalueR - lowvalueR)*ratio;
			
			wavetable_freq = wavetable[0];
			freqRatio = note_freq/wavetable_freq;

			midsample += freqRatio;
			midsample > wavetable_sampleslength ? while (
				midsample -= wavetable_sampleslength;
				midsample > wavetable_sampleslength;
			);
			note[N_SAMPLEPOS] = midsample;
			
			spl0 += midvalueL*amp;
			spl1 += midvalueR*amp;
		);

		note[N_SAMPLESFROMSTART] += 1;
		note[N_SAMPLESFROMEND] += 1;
	);
	note += notes_step;
	note < note_active_end;
);

