desc:PadSynth
in_pin:none;
out_pin:Left
out_pin:Right

import ui-lib.jsfx-inc

@init

// can_recompute = 0;
// action_recompute = 0;
// recompute_index - zero initially;
recompute_chunk = 1; // Recompute at most one waveform per block, so that we don't freeze the UI completely
polyphony = 64;
invsrate = 1/srate;

fftblock = 0;
fftblock_end = 65536;

uiblock_end = ui_setup(fftblock_end);

// Description of all effects in the system
fx_spec_start = uiblock_end;
fx_spec_count = FX_SPECLIST_INDEX##;
fx_spec_headerlength = FX_HEADER##;
fx_spec_modlength = FX_MOD##;
fx_spec_var_count = 10; // Maximum number of modulatable parameters
fx_spec_step = fx_spec_headerlength + fx_spec_modlength*fx_spec_var_count;
fx_spec_end = fx_spec_start + fx_spec_step*fx_spec_count;

fx_list_start = fx_spec_end;
fx_list_count = 10;
fx_list_headerlength = FX##; // enabled, type, name
fx_list_statelength = 16;
fx_list_step = fx_list_headerlength + fx_list_statelength;
fx_list_end = fx_list_start + fx_list_step*fx_list_count;

notes_start = fx_list_end;
note_headerlength = NOTE#;

note_fx_statelength = fx_list_statelength;
notes_step = note_headerlength + note_fx_statelength*fx_list_count;
notes_end = notes_start + polyphony*notes_step;
// Clear all notes
note = notes_start;
while (
	note[NOTE#ACTIVE] = 0;
	note += notes_step;
	note < notes_end;
);

wavetables_start = notes_end;
wavetables_count = 18;
wavetable_sampleslength = 32768;
wavetable_headerlength = 1; // Freq
wavetable_step = wavetable_headerlength + wavetable_sampleslength*2;
wavetables_end = wavetables_start + wavetables_count*wavetable_step;

display_wavetable_index = floor(wavetables_count/2);

volume_db = -12;
volume = pow(10, volume_db/20);
note_maxduration = 60*60*24*365;

wavetable_maxfreq = 18000;
wavetable_refsrate = 48000;
// 6+ octaves, centred on 440
wavetable_low = 50;
wavetable_high = 4000;

effectspec = fx_spec_start + fx_spec_count*FX_SPECLIST_INDEX#LFO;
effectspec[FX_HEADER#NAME] = "LFO";
effectspec[FX_HEADER#MODCOUNT] = 2;
effectspec[FX_HEADER#SPEC_SCREEN] = "effect.lfo";
modspec = effectspec + fx_spec_headerlength;
modspec[FX_MOD#NAME] = "Frequency";
modspec[FX_MOD#TYPE] = FX_MODTYPE#ADD;
modspec[FX_MOD#RANGE] = 2;

effectspec[FX_HEADER#FUNC_INIT] = {effect_init}effect_init_lfo;
function effect_init_lfo(effect) local(mods, state) (
	effect[FX#ENABLED] = 1;
	effect[FX#INDEX] = FX_SPECLIST_INDEX#LFO;
	effect[FX#NAME] = "LFO Modulator";
	
	state = effect + fx_list_headerlength;
	state[0] = -1; // Initial target: note itself
	state[1] = 1; // Note amplitude
	state[2] = FX_MODTYPE#MULT;
	
	state[3] = 5; // Freq
	state[4] = 0.5; // Amp
);
function effect_swap_lfo(effect, fxIndex1, fxIndex2) (
	state = effect + fx_list_headerlength;

	state[0] == fxIndex1 ? (
		state[0] = fxIndex2;
	) : state[0] == fxIndex2 ? (
		state[0] = fxIndex1;
	);
	state[0] < -1 ? (
		state[0] = -1;
		state[1] = 1;
		state[2] = FX_MODTYPE#MULT;
		state[3] = 4;
		state[4] = 0.5;
	);
);
function effect_note_setup_lfo(effect, note, notestate) local(state, targetIndex) (
	state = effect + fx_list_headerlength;
	// Two modulatable parameters
	notestate[0] = log(state[3]); // freq
	notestate[1] = state[4]; // amp
	
	targetIndex = state[0] < 0 ? (
		state[1] == 0 ? NOTE#FREQ : NOTE#AMP;
	) : (
		0;
	);
	// Use the remainder for private state
	notestate[2] = targetIndex;
	notestate[3] = state[2]; // Modulation type
	notestate[4] = 0; // Phase
);
function effect_note_exec_lfo(effect, note, notestate) local(angFreq, value) (
	angFreq = 2*$pi*exp(notestate[0])*invsrate;
	notestate[4] += angFreq;
	value = notestate[1]*sin(notestate[4])*notestate[1];
	notestate[3] == FX_MODTYPE#ADD ? (
		note[notestate[2]] += value;
	) : (
		note[notestate[2]] *= (1 + value);
	);
);

function effect_swap(effect, fxIndex1, fxIndex2) local(note) (
	effect[1] == FX_SPECLIST_INDEX#LFO ? (
		effect_swap_lfo(effect, fxIndex1, fxIndex2);
	);
	
	// Stop all notes, because their internal state is now in the wrong order
	note = notes_start;
	while (
		note[0] = 0;
		note += notes_step;
		note < notes_end;
	);
);
function effect_note_setup(effect, note, notestate) (
	effect[1] == FX_SPECLIST_INDEX#LFO ? (
		effect_note_setup_lfo(effect, note, notestate);
	);
);
function effect_note_exec(effect, note, notestate) (
	effect[1] == FX_SPECLIST_INDEX#LFO ? (
		effect_note_exec_lfo(effect, note, notestate);
	);
);

function {effect_init}(effect_slot);

function reset_to_defaults() local(i, note_effect, effect_spec) (
	action_recompute = 1;
	can_recompute = 1;
	has_set_parameters = 1;
	
	param_width_cents = 20;
	param_attack = 0.01;
	param_decay = 0.3;
	param_sustain = 0.75;
	param_release = 0.03;
	param_env_linear = 0;
	
	i = 0;
	while (
		note_effect = fx_list_start + i*fx_list_step;
		note_effect[0] = 0; // Disabled
		i < fx_list_count;
	);
	note_effect = fx_list_start; // First slot
	effect_spec = fx_spec_start + FX_SPECLIST_INDEX#LFO*fx_spec_step;
	{effect_init:effect_spec[FX_HEADER#FUNC_INIT]}(note_effect);
);
!has_set_parameters ? reset_to_defaults();

function log_to_slider(value, low, high) (
	log(value/low)/log(high/low);
);
function slider_to_log(value, low, high) (
	exp(log(low) + log(high/low)*value);
);
function range_to_slider(value, low, high) (
	(value - low)/(high - low);
);
function slider_to_range(value, low, high) (
	low + (high - low)*value;
);
function power_to_slider(value, low, high, power) (
	pow((value - low)/(high - low), 1/power);
);
function slider_to_power(value, low, high, power) (
	low + (high - low)*pow(value, power);
);

@block

action_recompute ? (
	can_recompute = 0;
	action_recompute = 0;
	recompute_index = 0;
);

recompute_index < wavetables_count ? (
	param_width = param_width_cents/1200*log(2);
	wavetable_index = recompute_index;
	recompute_stop_index = min(wavetables_count, recompute_index + recompute_chunk);
	while (
		ratio = (wavetable_index + 0.5)/wavetables_count;
		base_freq = exp(log(wavetable_low) + log(wavetable_high/wavetable_low)*ratio);
		// Zero it out
		i = 0;
		while (
			fftblock[i] = 0;
			i += 1;
			i < wavetable_sampleslength*2;
		);
		
		harmonic_range_factor = exp(param_width*2);
		i = 1;
		while (
			power = 0;
			indexfreq = i/wavetable_sampleslength*wavetable_refsrate;
			indexwidth = log((i + 1)/i);
			harmonic_freq = base_freq*floor(indexfreq/base_freq/harmonic_range_factor);
			end_freq = min(wavetable_maxfreq, indexfreq*harmonic_range_factor);
			while (
				harmonic_amp = 1/harmonic_freq;
				harmonic_power = harmonic_amp*harmonic_amp;
				log_width = max(indexwidth, param_width);
				hz_width = exp(log_width)*harmonic_freq;
				stddistance = log(indexfreq/harmonic_freq)*2/log_width;
				power += harmonic_power/hz_width*exp(-stddistance*stddistance); // Gaussian

				harmonic_freq += base_freq;
				harmonic_freq < end_freq;
			);
			amp = sqrt(power);
			phase1 = rand(2*$pi);
			//phase2 = rand(2*$pi);
			// Attempt to even out the mid-channel energy while still making the two channels uncorrelated
			phase2 = (rand() < 0.5) ? phase1 + $pi/2 : phase1 - $pi/2;
	
			leftR = amp*cos(phase1);
			leftI = amp*sin(phase1);
			rightR = amp*cos(phase2);
			rightI = amp*sin(phase2);
			
			0 ? ( // Mid/side decode
				mid = leftR;
				side = rightR;
				leftR = mid - side;
				rightR = mid + side;
				mid = leftI;
				side = rightI;
				leftI = mid - side;
				rightI = mid + side;
			);

			i2 = wavetable_sampleslength - i;
			fftblock[2*i] = leftR - rightI;
			fftblock[2*i + 1] = leftI + rightR;
			fftblock[2*i2] = leftR + rightI;
			fftblock[2*i2 + 1] = rightR - leftI;

			i += 1;
			i < wavetable_sampleslength/2;
		);
		
		// IFFT
		fft_ipermute(fftblock, 32768);
		ifft(fftblock, 32768);

		// Normalise
		sum2 = 0;
		maxabs = 0;
		i = 0;
		while (
			sum2 += fftblock[i]*fftblock[i];
			maxabs = max(maxabs, abs(fftblock[i]));
			i += 1;
			i < wavetable_sampleslength*2;
		);
		factor = 0.25/sqrt(sum2/(2*wavetable_sampleslength));

		// Place in wavetable
		wavetable = wavetables_start + wavetable_step*wavetable_index;
		wavetable[0] = base_freq*srate/wavetable_refsrate;
		wavetable_samples = wavetable + wavetable_headerlength;
		assignedwavetable = wavetable;
		i = 0;
		while (
			wavetable_samples[i] = fftblock[i]*factor;
			i += 1;
			i < wavetable_sampleslength*2;
		);
		first = fftblock[0];
		first2 = wavetable_samples[0];
		
		wavetable_index += 1;
		wavetable_index < recompute_stop_index;
	);
	recompute_index = wavetable_index;
);

midi_event = midirecv(midi_offset, midi_msg1, midi_msg23);
midi_event ? while (
	midisend(midi_offset, midi_msg1, midi_msg23); // passthrough
	midi_type = midi_msg1>>4;
	midi_channel = midi_msg1&0x0f;
	midi_msg2 = midi_msg23&$xff; // note / controller
	midi_msg3 = midi_msg23>>8; // velocity / value
	(midi_type == $x9 && midi_msg3 != 0) ? (
		// Note on
		note = notes_start;
		while (
			note[0] ? (
				note += notes_step;
				note < notes_end;
			);
			note[0] && note < notes_end;
		);
		// Found a free slot
		note < notes_end ? (
			// Note parameters
			note[0] = 1;
			note[NOTE#CHANNEL] = midi_channel;
			note[NOTE#NOTE] = midi_msg2;
			note[NOTE#VEL] = midi_msg3;
			note[NOTE#SECONDSFROMSTART] = -midi_offset*invsrate;
			note[NOTE#SECONDSFROMEND] = -note_maxduration;
			note[NOTE#FREQ_BASE] = 440*pow(2, (note[NOTE#NOTE] - 69)/12);
			note[NOTE#AMP_BASE] = volume*note[NOTE#VEL]/127;
			
			// Wavetable params
			wavetable_index = log(note[NOTE#FREQ_BASE]/wavetable_low)/log(wavetable_high/wavetable_low)*wavetables_count;
			wavetable_index = min(wavetables_count - 1, max(0, floor(wavetable_index)));
			note[NOTE#WAVEINDEX] = wavetable_index; // Wavetable #0
			note[NOTE#SAMPLEPOS] = rand(wavetable_sampleslength);
			display_wavetable_index = wavetable_index;
			
			// FX note setup
			i = 0;
			while (
				effect = fx_list_start + i*fx_list_step;
				notestate = note + note_headerlength + note_fx_statelength*i;
				effect[0] ? (
					effect_note_setup(effect, note, notestate);
				);
				i += 1;
				i < fx_list_count;
			);
		);
	) : (midi_type == $x8 || (midi_type == $x9 && midi_msg3 == 0)) ? (
		// Note off 
		note = notes_start;
		while (
			note[0] && note[NOTE#CHANNEL] == midi_channel && note[NOTE#NOTE] == midi_msg2 ? (
				note[NOTE#SECONDSFROMEND] = max(note[NOTE#SECONDSFROMEND], -midi_offset*invsrate);
			);
			note += notes_step;
			note < notes_end;
		);
	);
	
	midi_event = midirecv(midi_offset, midi_msg1, midi_msg23);
);

polyphony_current = 0;
note = notes_start;
note_active_end = notes_start;
while (
	note[0] ? (
		polyphony_current += 1;
		note_active_end = note + notes_step;
	);
	note += notes_step;
	note < notes_end;
);

@sample

note = notes_start;
while (
	note[0] ? (
		note[NOTE#SECONDSFROMSTART] > 0 ? (
			secondsFromStart = note[NOTE#SECONDSFROMSTART];
			secondsFromEnd = note[NOTE#SECONDSFROMEND];
			note[NOTE#FREQ] = note[NOTE#FREQ_BASE];
			note[NOTE#AMP] = note[NOTE#AMP_BASE];
			
			// FX note setup
			i = 0;
			while (
				effect = fx_list_start + i*fx_list_step;
				notestate = note + note_headerlength + note_fx_statelength*i;
				effect[0] ? (
					effect_note_exec(effect, note, notestate);
				);
				i += 1;
				i < fx_list_count;
			);

			env = 1;
			stretch = param_env_linear ? 1 : 2;
			attack = param_attack;
			decay = param_decay*stretch;
			sustain = param_sustain;
			release = param_release*stretch;

			secondsFromStart < attack ? (
				env *= secondsFromStart/attack;
			) : (
				secondsFromAttack = secondsFromStart - attack;
				secondsFromAttack < decay ? (
					env *= 1 - (1 - sustain)*secondsFromAttack/decay;
				) : (
					env *= sustain;
				);
			);
			secondsFromEnd > 0 ? (
				secondsFromEnd > release ? (
					env = 0;
					note[0] = 0;
				) : (
					env *= 1 - secondsFromEnd/release;
				);
			);
			!param_env_linear ? env = env*env*env;
			note[NOTE#AMP] *= env;
			
			wavetable = wavetables_start + note[NOTE#WAVEINDEX]*wavetable_step;
			wavetable_samples = wavetable + wavetable_headerlength;
			midsample = note[NOTE#SAMPLEPOS];
			lowsample = floor(midsample);
			highsample = ceil(midsample)%wavetable_sampleslength;
			ratio = (midsample - lowsample);

			lowvalue = wavetable_samples[2*lowsample];
			highvalue = wavetable_samples[2*highsample];
			midvalueL = lowvalue + (highvalue - lowvalue)*ratio;

			lowvalue = wavetable_samples[2*lowsample + 1];
			highvalue = wavetable_samples[2*highsample + 1];
			midvalueR = lowvalue + (highvalue - lowvalue)*ratio;
			
			wavetable_freq = wavetable[0];
			freqRatio = note[NOTE#FREQ]/wavetable_freq;

			midsample += freqRatio;
			midsample > wavetable_sampleslength ? while (
				midsample -= wavetable_sampleslength;
				midsample > wavetable_sampleslength;
			);
			note[NOTE#SAMPLEPOS] = midsample;
			
			spl0 += midvalueL*note[NOTE#AMP];
			spl1 += midvalueR*note[NOTE#AMP];
		);

		note[NOTE#SECONDSFROMSTART] += invsrate;
		note[NOTE#SECONDSFROMEND] += invsrate;
	);
	note += notes_step;
	note < note_active_end;
);

@gfx

ui_start("main"); // Default screen

ui_screen() == "main" ? (
	ui_split_top(50) + (
		control_button("PadSynth") ? (
			button_clicked = 1;
			ui_screen_open("about");
		);
	) + ui_pop();
) : ui_system();