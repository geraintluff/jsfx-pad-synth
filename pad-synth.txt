desc:PadSynth
in_pin:none;
out_pin:Left
out_pin:Right

import ui-lib.jsfx-inc

@init

// can_recompute = 0;
// action_recompute = 0;
// recompute_index - zero initially;
recompute_chunk = 1; // Recompute at most one waveform per block, so that we don't freeze the UI completely
polyphony = 64;
invsrate = 1/srate;

fftblock = 0;
fftblock_end = 65536;

string_slot_counter = 1;
function string_slot(current) local(result) (
	(current > 1 && current < string_slot_counter) ? (
		current;
	) : (
		string_slot_counter < 1024 ? (
			result = string_slot_counter;
			string_slot_counter += 1;
			result;
		) : (
			ui_error("Ran out of string slots!");
			#string_slot_singleton; // All remaining strings the same
		);
	);
);

uiblock_end = ui_setup(fftblock_end);

// Description of all effects in the system
fx_spec_start = uiblock_end;
fx_spec_count = FX_SPECLIST_INDEX##;
fx_spec_headerlength = FX_HEADER##;
fx_spec_modlength = FX_MOD##;
fx_spec_var_count = 10; // Maximum number of modulatable parameters
fx_spec_step = fx_spec_headerlength + fx_spec_modlength*fx_spec_var_count;
fx_spec_end = fx_spec_start + fx_spec_step*fx_spec_count;

fx_list_start = fx_spec_end;
//fx_list_count = 0; // Don't actually reset it here, it'll wipe all effects on playback restart!
fx_list_maxcount = 10;
fx_list_headerlength = FX##;
fx_list_statelength = 16;
fx_list_step = fx_list_headerlength + fx_list_statelength;
fx_list_end = fx_list_start + fx_list_step*fx_list_maxcount;

notes_start = fx_list_end;
note_headerlength = NOTE#;

note_fx_statelength = fx_list_statelength;
notes_step = note_headerlength + note_fx_statelength*fx_list_maxcount;
notes_end = notes_start + polyphony*notes_step;
// Clear all notes
function clear_all_notes() local(note) (
	note = notes_start;
	while (
		note[NOTE#ACTIVE] = 0;
		note += notes_step;
		note < notes_end;
	);
);
clear_all_notes();

wavetables_start = notes_end;
wavetables_count = 18;
wavetable_sampleslength = 32768;
wavetable_headerlength = WAVETABLE##; // Freq
wavetable_step = wavetable_headerlength + wavetable_sampleslength*2;
wavetables_end = wavetables_start + wavetables_count*wavetable_step;

display_wavetable_index = floor(wavetables_count/2);

volume_db = -12;
volume = pow(10, volume_db/20);
note_maxduration = 60*60*24*365;

wavetable_maxfreq = 18000;
wavetable_refsrate = 48000;
// 6+ octaves, centred on 440
wavetable_low = 50;
wavetable_high = 4000;

// Spec for LFO
LFO_NOTE_STATE## > note_fx_statelength ? ui_error("note state too small for LFO");
LFO_STATE## > fx_list_statelength ? ui_error("effect state too small for LFO");
effectspec = fx_spec_start + fx_spec_count*FX_SPECLIST_INDEX#LFO(0);
effectspec[FX_HEADER#NAME] = "LFO";
effectspec[FX_HEADER#MODCOUNT] = 2;
modspec = effectspec + fx_spec_headerlength + fx_spec_modlength*LFO_NOTE_STATE#LOG_FREQ(0);
modspec[FX_MOD#NAME] = "Frequency";
modspec[FX_MOD#TYPE] = FX_MODTYPE#ADD;
modspec[FX_MOD#RANGE] = 2;
modspec = effectspec + fx_spec_headerlength + fx_spec_modlength*LFO_NOTE_STATE#AMP(1);
modspec[FX_MOD#NAME] = "Amount";
modspec[FX_MOD#TYPE] = FX_MODTYPE#MULT;
modspec[FX_MOD#RANGE] = 1;

effectspec[FX_HEADER#FUNC_INIT] = {effect_init}effect_init_lfo;
function effect_init_lfo(effect) local(mods, state) (
	effect[FX#SPEC_INDEX] = FX_SPECLIST_INDEX#LFO;
	
	effect[FX#NAME] = "LFO Modulator";
	
	state = effect + fx_list_headerlength;
	state[LFO_STATE#MOD_EFFECT(0)] = -1; // Initial target: note itself
	state[LFO_STATE#MOD_INDEX(1)] = 1; // Note amplitude
	state[LFO_STATE#MOD_TYPE(2)] = FX_MODTYPE#MULT;
	
	state[LFO_STATE#FREQ(3)] = 5; // Freq
	state[LFO_STATE#AMP(4)] = 0.5; // Amp
);
effectspec[FX_HEADER#CONFIG_UI_FUNCTION] = {config_ui}effect_ui_lfo;
function effect_ui_lfo(effect) (
	state = effect + fx_list_headerlength;
	ui_split_n(2, 1);
		state[LFO_STATE#AMP] = control_hslider(state[LFO_STATE#AMP], 0, 1, 1);
	ui_split_next();
		state[LFO_STATE#FREQ] = control_hslider(state[LFO_STATE#FREQ], 0, 100, 3);
	ui_pop();
);
function effect_swap_lfo(effect, fxIndex1, fxIndex2) (
	state = effect + fx_list_headerlength;

	state[LFO_STATE#MOD_EFFECT] == fxIndex1 ? (
		state[LFO_STATE#MOD_EFFECT] = fxIndex2;
	) : state[LFO_STATE#MOD_EFFECT] == fxIndex2 ? (
		state[LFO_STATE#MOD_EFFECT] = fxIndex1;
	);
	state[LFO_STATE#MOD_EFFECT] < -1 ? (
		// Our target was just deleted - reset the effect
		effect_init_lfo(effect);
	);
);
function effect_note_setup_lfo(effect, note, notestate) local(state, targetIndex) (
	state = effect + fx_list_headerlength;
	// Two modulatable parameters
	notestate[LFO_NOTE_STATE#LOG_FREQ] = log(state[LFO_STATE#FREQ]); // freq
	notestate[LFO_NOTE_STATE#AMP] = state[LFO_STATE#AMP]; // amp
	
	targetIndex = state[LFO_STATE#MOD_EFFECT] < 0 ? (
		state[LFO_STATE#MOD_INDEX] == 0 ? NOTE#LOG_FREQ : NOTE#AMP;
	) : (
		0;
	);
	// Use the remainder for private state
	notestate[LFO_NOTE_STATE#TARGET] = targetIndex;
	notestate[LFO_NOTE_STATE#MODTYPE] = state[LFO_STATE#MOD_TYPE]; // Modulation type
	notestate[LFO_NOTE_STATE#PHASE] = 0; // Phase
);
function effect_note_exec_lfo(effect, note, notestate) local(angFreq, value, targetIndex) (
	targetIndex = notestate[LFO_NOTE_STATE#TARGET];
	targetIndex > 0 ? (
		angFreq = 2*$pi*exp(notestate[LFO_NOTE_STATE#LOG_FREQ(0)])*invsrate;
		notestate[LFO_NOTE_STATE#PHASE] += angFreq;
		value = notestate[LFO_NOTE_STATE#AMP]*sin(notestate[LFO_NOTE_STATE#PHASE]);
		notestate[LFO_NOTE_STATE#MODTYPE] == FX_MODTYPE#ADD ? (
			note[targetIndex] += value;
		) : (
			note[targetIndex] *= (1 + value);
		);
	);
);

function {effect_init}(effect_slot);
function {config_ui}(effect);

function append_effect(index) local(spec, effect) (
	debug.append_effect += 1;
	fx_list_count < fx_list_maxcount ? (
		debug.append_effect_success += 1;
		// TODO: check the index is valid, otherwise insert placeholder (negative index)
		effect = fx_list_start + fx_list_step*fx_list_count;
		fx_list_count += 1;
		spec = fx_spec_start + fx_spec_step*index;
		{effect_init:spec[FX_HEADER#FUNC_INIT]}(effect);
		effect;
	) : 0; // This should be checked first, otherwise you'll overwrite the fft area
);
// TODO: make these use function references
function effect_swap(effect, fxIndex1, fxIndex2) local(note) (
	effect[FX#SPEC_INDEX] == FX_SPECLIST_INDEX#LFO ? (
		effect_swap_lfo(effect, fxIndex1, fxIndex2);
	);
	
	// Stop all notes, because their internal state is now in the wrong order
	note = notes_start;
	while (
		note[NOTE#ACTIVE] = 0;
		note += notes_step;
		note < notes_end;
	);
);
function effect_note_setup(effect, note, notestate) (
	effect[FX#SPEC_INDEX] == FX_SPECLIST_INDEX#LFO ? (
		effect_note_setup_lfo(effect, note, notestate);
	);
);
function effect_note_exec(effect, note, notestate) (
	effect[FX#SPEC_INDEX] == FX_SPECLIST_INDEX#LFO ? (
		effect_note_exec_lfo(effect, note, notestate);
	);
);

function reset_to_defaults() (
	action_recompute = 1;
	can_recompute = 1;
	has_set_parameters = 1;
	
	param_width_cents = 20;
	param_attack = 0.01;
	param_decay = 0.3;
	param_sustain = 0.75;
	param_release = 0.03;
	param_env_linear = 0;

	fx_list_count = 0;
	append_effect(FX_SPECLIST_INDEX#LFO);
);
!has_set_parameters ? reset_to_defaults();

@block

action_recompute ? (
	can_recompute = 0;
	action_recompute = 0;
	recompute_index = 0;
);

recompute_index < wavetables_count ? (
	param_width = param_width_cents/1200*log(2);
	wavetable_index = recompute_index;
	recompute_stop_index = min(wavetables_count, recompute_index + recompute_chunk);
	while (
		ratio = (wavetable_index + 0.5)/wavetables_count;
		base_freq = exp(log(wavetable_low) + log(wavetable_high/wavetable_low)*ratio);
		// Zero it out
		i = 0;
		while (
			fftblock[i] = 0;
			i += 1;
			i < wavetable_sampleslength*2;
		);
		
		harmonic_range_factor = exp(param_width*2);
		i = 1;
		while (
			power = 0;
			indexfreq = i/wavetable_sampleslength*wavetable_refsrate;
			indexwidth = log((i + 1)/i);
			harmonic_freq = base_freq*floor(indexfreq/base_freq/harmonic_range_factor);
			end_freq = min(wavetable_maxfreq, indexfreq*harmonic_range_factor);
			while (
				harmonic_amp = 1/harmonic_freq;
				harmonic_power = harmonic_amp*harmonic_amp;
				log_width = max(indexwidth, param_width);
				hz_width = exp(log_width)*harmonic_freq;
				stddistance = log(indexfreq/harmonic_freq)*2/log_width;
				power += harmonic_power/hz_width*exp(-stddistance*stddistance); // Gaussian

				harmonic_freq += base_freq;
				harmonic_freq < end_freq;
			);
			amp = sqrt(power);
			phase1 = rand(2*$pi);
			//phase2 = rand(2*$pi);
			// Attempt to even out the mid-channel energy while still making the two channels uncorrelated
			phase2 = (rand() < 0.5) ? phase1 + $pi/2 : phase1 - $pi/2;
	
			leftR = amp*cos(phase1);
			leftI = amp*sin(phase1);
			rightR = amp*cos(phase2);
			rightI = amp*sin(phase2);
			
			0 ? ( // Mid/side decode
				mid = leftR;
				side = rightR;
				leftR = mid - side;
				rightR = mid + side;
				mid = leftI;
				side = rightI;
				leftI = mid - side;
				rightI = mid + side;
			);

			i2 = wavetable_sampleslength - i;
			fftblock[2*i] = leftR - rightI;
			fftblock[2*i + 1] = leftI + rightR;
			fftblock[2*i2] = leftR + rightI;
			fftblock[2*i2 + 1] = rightR - leftI;

			i += 1;
			i < wavetable_sampleslength/2;
		);
		
		// IFFT
		fft_ipermute(fftblock, 32768);
		ifft(fftblock, 32768);

		// Normalise
		sum2 = 0;
		maxabs = 0;
		i = 0;
		while (
			sum2 += fftblock[i]*fftblock[i];
			maxabs = max(maxabs, abs(fftblock[i]));
			i += 1;
			i < wavetable_sampleslength*2;
		);
		factor = 0.25/sqrt(sum2/(2*wavetable_sampleslength));

		// Place in wavetable
		wavetable = wavetables_start + wavetable_step*wavetable_index;
		wavetable[WAVETABLE#FREQ] = base_freq*srate/wavetable_refsrate;
		wavetable_samples = wavetable + wavetable_headerlength;
		assignedwavetable = wavetable;
		i = 0;
		while (
			wavetable_samples[i] = fftblock[i]*factor;
			i += 1;
			i < wavetable_sampleslength*2;
		);
		
		wavetable_index += 1;
		wavetable_index < recompute_stop_index;
	);
	recompute_index = wavetable_index;
);

midi_event = midirecv(midi_offset, midi_msg1, midi_msg23);
midi_event ? while (
	midisend(midi_offset, midi_msg1, midi_msg23); // passthrough
	midi_type = midi_msg1>>4;
	midi_channel = midi_msg1&0x0f;
	midi_msg2 = midi_msg23&$xff; // note / controller
	midi_msg3 = midi_msg23>>8; // velocity / value
	(midi_type == $x9 && midi_msg3 != 0) ? (
		// Note on
		note = notes_start;
		while (
			note[NOTE#ACTIVE] ? (
				note += notes_step;
				note < notes_end;
			);
			note[NOTE#ACTIVE] && note < notes_end;
		);
		// Found a free slot
		note < notes_end ? (
			// Note parameters
			note[NOTE#ACTIVE] = 1;
			note[NOTE#CHANNEL] = midi_channel;
			note[NOTE#NOTE] = midi_msg2;
			note[NOTE#VEL] = midi_msg3;
			note[NOTE#SECONDSFROMSTART] = -midi_offset*invsrate;
			note[NOTE#SECONDSFROMEND] = -note_maxduration;
			note[NOTE#LOG_FREQ_BASE] = log(440*pow(2, (note[NOTE#NOTE] - 69)/12));
			note[NOTE#AMP_BASE] = volume*note[NOTE#VEL]/127;
			
			// Wavetable params
			wavetable_index = (note[NOTE#LOG_FREQ_BASE] - log(wavetable_low))/log(wavetable_high/wavetable_low)*wavetables_count;
			wavetable_index = min(wavetables_count - 1, max(0, floor(wavetable_index)));
			note[NOTE#WAVEINDEX] = wavetable_index; // Wavetable #0
			note[NOTE#SAMPLEPOS] = rand(wavetable_sampleslength);
			display_wavetable_index = wavetable_index;
			
			// FX note setup
			i = 0;
			i < fx_list_count ? while (
				effect = fx_list_start + i*fx_list_step;
				notestate = note + note_headerlength + note_fx_statelength*i;
				effect_note_setup(effect, note, notestate);
				i += 1;
				i < fx_list_count;
			);
		);
	) : (midi_type == $x8 || (midi_type == $x9 && midi_msg3 == 0)) ? (
		// Note off 
		note = notes_start;
		while (
			note[NOTE#ACTIVE] && note[NOTE#CHANNEL] == midi_channel && note[NOTE#NOTE] == midi_msg2 ? (
				note[NOTE#SECONDSFROMEND] = max(note[NOTE#SECONDSFROMEND], -midi_offset*invsrate);
			);
			note += notes_step;
			note < notes_end;
		);
	);
	
	midi_event = midirecv(midi_offset, midi_msg1, midi_msg23);
);

polyphony_current = 0;
note = notes_start;
note_active_end = notes_start;
while (
	note[NOTE_ACTIVE] ? (
		polyphony_current += 1;
		note_active_end = note + notes_step;
	);
	note += notes_step;
	note < notes_end;
);

@sample

note = notes_start;
while (
	note[NOTE#ACTIVE] ? (
		note[NOTE#SECONDSFROMSTART] > 0 ? (
			secondsFromStart = note[NOTE#SECONDSFROMSTART];
			secondsFromEnd = note[NOTE#SECONDSFROMEND];
			note[NOTE#LOG_FREQ] = note[NOTE#LOG_FREQ_BASE];
			note[NOTE#AMP] = note[NOTE#AMP_BASE];
			
			// FX note setup
			i = 0;
			i < fx_list_count ? while (
				effect = fx_list_start + i*fx_list_step;
				notestate = note + note_headerlength + note_fx_statelength*i;
				effect_note_exec(effect, note, notestate);
				i += 1;
				i < fx_list_count;
			);

			env = 1;
			stretch = param_env_linear ? 1 : 1;
			attack = param_attack;
			decay = param_decay*stretch;
			sustain = param_sustain;
			release = param_release*stretch;

			secondsFromStart < attack ? (
				env *= secondsFromStart/attack;
			) : (
				secondsFromAttack = secondsFromStart - attack;
				secondsFromAttack < decay ? (
					env *= 1 - (1 - sustain)*secondsFromAttack/decay;
				) : (
					env *= sustain;
				);
			);
			secondsFromEnd > 0 ? (
				secondsFromEnd > release ? (
					env = 0;
					note[NOTE#ACTIVE] = 0;
				) : (
					env *= 1 - secondsFromEnd/release;
				);
			);
			!param_env_linear ? env = env*env*env;
			note[NOTE#AMP] *= env;
			
			wavetable = wavetables_start + note[NOTE#WAVEINDEX]*wavetable_step;
			wavetable_samples = wavetable + wavetable_headerlength;
			midsample = note[NOTE#SAMPLEPOS];
			lowsample = floor(midsample);
			highsample = ceil(midsample)%wavetable_sampleslength;
			ratio = (midsample - lowsample);

			lowvalue = wavetable_samples[2*lowsample];
			highvalue = wavetable_samples[2*highsample];
			midvalueL = lowvalue + (highvalue - lowvalue)*ratio;

			lowvalue = wavetable_samples[2*lowsample + 1];
			highvalue = wavetable_samples[2*highsample + 1];
			midvalueR = lowvalue + (highvalue - lowvalue)*ratio;
			
			wavetable_freq = wavetable[WAVETABLE#FREQ];
			freqRatio = exp(note[NOTE#LOG_FREQ])/wavetable_freq;

			midsample += freqRatio;
			midsample > wavetable_sampleslength ? while (
				midsample -= wavetable_sampleslength;
				midsample > wavetable_sampleslength;
			);
			note[NOTE#SAMPLEPOS] = midsample;
			
			spl0 += midvalueL*note[NOTE#AMP];
			spl1 += midvalueR*note[NOTE#AMP];
		);

		note[NOTE#SECONDSFROMSTART] += invsrate;
		note[NOTE#SECONDSFROMEND] += invsrate;
	);
	note += notes_step;
	note < note_active_end;
);

@gfx

function draw_waveform() local(wavetable, samples, value, x, y, gi, gis, box_left, box_top, box_width, box_height) (
	box_left = ui_left();
	box_top = ui_top();
	box_width = ui_width();
	box_height = ui_height();

	wavetable = wavetables_start + display_wavetable_index*wavetable_step;
	samples = wavetable + wavetable_headerlength;
	gis = ceil(wavetable_sampleslength*0.25/box_width);
	// Left - blue
	gi = 0;
	gfx_r = 0.25;
	gfx_g = 0.5;
	gfx_b = 0.75;
	gfx_x = box_left;
	gfx_y = ui_top() + box_height/2;
	while (
		value = min(1, max(-1, samples[gi*2]));
		x = box_left + gi/wavetable_sampleslength*box_width;
		y = box_top + 0.5*(1 - value)*box_height;
		gfx_lineto(x, y, 0);
		gi += 1;
		gi < wavetable_sampleslength;
	);
	// Right - orange
	gi = 0;
	gfx_r = 0.75;
	gfx_g = 0.5;
	gfx_b = 0.25;
	gfx_x = box_left;
	gfx_y = box_top + box_height/2;
	while (
		value = min(1, max(-1, samples[gi*2 + 1]));
		x = box_left + gi/wavetable_sampleslength*box_width;
		y = box_top + 0.5*(1 - value)*box_height;
		gfx_lineto(x, y, 0);
		gi += 1;
		gi < wavetable_sampleslength;
	);
	ui_color(0, 0, 0);
	ui_border();
);

function named_hslider(name, value, range_low, range_high, curve, displayvalue, displayformat) (
	ui_split_left(100);
		ui_pad();
		ui_align(1, 0.5);
		ui_text(name);
	ui_pop();
	ui_split_right(100);
		ui_pad();
		ui_align(0, 0.5);
		ui_textnumber(displayvalue, displayformat);
	ui_pop();
	ui_push_heighttext(-1);
		value = control_hslider(value, range_low, range_high, curve);
	ui_pop();
	value;
);

ui_start("main"); // Default screen

slider_value = slider_value ? slider_value : 0.5;

ui_screen() == "main" ? (
	control_navbar("PadSynth", "About", "about");
	ui_pad();
	ui_split_toptext("");
		ui_split_n(2, 0);
			control_button("Envelope (ADSR)") ? (
				ui_screen_open("envelope");
			);
		ui_split_next();
			display_first_effect = fx_list_start;
			debug.display.effect = display_first_effect;
			debug.display.effect_name = display_first_effect[FX#NAME];
			control_button(display_first_effect[FX#NAME]) ? (
				ui_screen_open("edit-effect");
				ui_screen_set(0, display_first_effect);
			);
		ui_pop();
	ui_pop();
	ui_padtop();
	
	ui_split_bottomtext("");
		ui_split_righttext("Regenerate");
			control_indicator_button("Regenerate", can_recompute) ? (
				can_recompute ? action_recompute = 1;
			);
		ui_pop();
	
		ui_split_lefttext("Width (cents)");
			ui_text("Width (cents)");
		ui_pop();
		ui_split_right(50);
			ui_textnumber(param_width_cents + 0.5, "%i");
		ui_pop();
		new_width_cents = control_hslider(param_width_cents, 5, 200, 3);
		new_width_cents != param_width_cents ? can_recompute = 1;
		param_width_cents = new_width_cents;
	ui_pop();
	ui_padbottom();
	
	ui_push();
		ui_fill(0, 0, 0);
		draw_waveform();
		control_gloss(1);
	ui_pop();
) : ui_screen() == "about" ? (
	control_navbar("About", 0, 0);
	
	ui_pad();

	ui_align(0.5, 0.67);
	text_height = ui_wraptext("This is a JSFX implementation of the 'padsynth' algorithm from ZynAddSubFX, which I love but hasn\'t been updated in a while.  It\'s not an exact replacement, but I\'m adding features as I need them.\n\nIt\'s a sample-based synth, where the samples are designed in the frequency domain (which allows customised harmonic spread) and then generated using an inverse FFT.\n\nThe GUI for this synth uses a JSFX UI library originally written for this synth, but is now a project of its own.");
	
	ui_push_above(text_height);
		ui_align(0.5, 0.5);
		ui_fontsize(20);
		ui_fontbold(1);
		ui_text("PadSynth");
		ui_push_belowtext("PadSynth");
			ui_fontsize(0);
			ui_fontbold(0);
			ui_fontitalic(1);
			ui_align(0.5, 0);
			ui_text("by Geraint Luff");
		ui_pop();
	ui_pop();
) : ui_screen() == "envelope" ? (
	control_navbar("Envelope (ADSR)", 0, 0);
	ui_split_n(5, 1);
		param_attack = named_hslider("Attack", param_attack, 0.001, 1.5, 3, floor(param_attack*1000 + 0.5), "%ims");
	ui_split_next();
		param_decay = named_hslider("Decay", param_decay, 0.001, 5, 3, floor(param_decay*1000 + 0.5), "%ims");
	ui_split_next();
		param_sustain = named_hslider("Sustain", param_sustain, 0, 1, 1, floor(param_sustain*100 + 0.5), "%i%%");
	ui_split_next();
		param_release = named_hslider("Release", param_release, 0.005, 5, 3, floor(param_release*1000 + 0.5), "%ims");
	ui_split_next();
		ui_pad2(100, 0);
		ui_push_heighttext("");
			ui_align(0, -1);
			param_env_linear = control_selector(param_env_linear, param_env_linear ? "Linear" : "Tapered", !param_env_linear, !param_env_linear);
		ui_pop();
	ui_pop();
) : ui_screen() == "edit-effect" ? (
	g_effect = ui_screen_get(0);
	g_effect_spec = fx_spec_start + fx_spec_step*g_effect[FX#SPEC_INDEX];

	control_navbar(g_effect[FX#NAME], 0, 0);
	effect_ui = g_effect_spec[FX_HEADER#CONFIG_UI_FUNCTION];
	{config_ui:effect_ui}(g_effect);
) : ui_system();

@serialize

// Serialisation is a sequence of (id, length, value).  All unrecognised IDs (currently) result in an error.
// We do our own string serialisation so that we can keep track of the length.
// The VAR_ID enum values should always force a value

function read_plain_var() local(var_length, value) (
	file_var(0, var_length);
	var_length ? while(
		file_var(0, value);
		var_length -= 1;
		var_length;
	);
	value;
);
function read_string_var(string) local(vars_read, char_count, char, string_length) (
	strcpy(string, "");
	string_length = 0;
	file_var(0, char_count);
	debug.read_string.char_count = char_count;
	vars_read = 1 + char_count;
	string_length < char_count ? while (
		file_var(0, char);
		str_setchar(string, string_length, char);
		string_length += 1;
		string_length < char_count;
	);
	vars_read;
);
function read_effect() local(read_length, effect, spec_index, var_id, i, var_length, value) (
	fx_list_count < fx_list_maxcount ? (
		file_var(0, read_length);
		
		file_var(0, spec_index);
		read_length -= 1;
		// TODO: check that the effect is a known type, otherwise put a placeholder in so the indices don't get screwed up (and remove placeholders at the end)
		
		effect = append_effect(spec_index);
		
		read_length > 0 ? while(
			file_var(0, var_id);
			debug.read_effect.var_id = var_id;
			read_length -= 1;
			var_id == VAR_ID#effect_name(104) ? (
				// Make sure it's pointing to a mutable string slot
				effect[FX#NAME] = string_slot(effect[FX#NAME]);
				debug.read_effect.effect = effect;
				debug.effect_name_slot = effect[FX#NAME];
				debug.effect_name_strlen1 = strlen(effect[FX#NAME]);
				// Read the variable into that slot
				read_length -= read_string_var(effect[FX#NAME]);
				debug.effect_name_strlen2 = strlen(effect[FX#NAME]);
			) : var_id == VAR_ID#effect_state(105) && effect >= 0 ? (
				file_var(0, var_length);
				read_length -= var_length + 1;
				effectstate = effect + fx_list_headerlength;
				i = 0;
				i < var_length ? while (
					file_var(0, value);
					effectstate[i] = value;
					i += 1;
					i < var_length;
				);
			) : (
				sprintf(#read_effect_error, "Unrecognised ID in effect: %f", var_id);
				ui_error(#read_effect_error);
				// Consume the data so we don't get out-of-sync and screw up the rest of the config in a potentially painful way
				file_var(0, var_length);
				read_length -= var_length + 1;
				var_length > 0 ? while (
					file_var(0, i);
					var_length -= 1;
					var_length > 0;
				);
			);
			read_length > 0;
		);
	) : (
		read_plain_var();
	);
);
function read_var() local(var_id, i, effect) (
	file_var(0, var_id);
	var_id == VAR_ID#param_width_cents(1) ? (
		param_width_cents = read_plain_var();
	) : var_id == VAR_ID#param_env_linear(99) ? (
		param_env_linear = read_plain_var();
	) : var_id == VAR_ID#param_attack(100) ? (
		param_attack = read_plain_var();
	) : var_id == VAR_ID#param_decay(101) ? (
		param_decay = read_plain_var();
	) : var_id == VAR_ID#param_sustain(102) ? (
		param_sustain = read_plain_var();
	) : var_id == VAR_ID#param_release(103) ? (
		param_release = read_plain_var();
	) : var_id == VAR_ID#effect(106) ? (
		read_effect();
	) : (
		ui_error("Unrecognised variable in state");
		read_plain_var();
	);
);
function write_plain_var(var_id, value) local(length) (
	length = 1;
	file_var(0, var_id);
	file_var(0, length);
	file_var(0, value);
);
function write_string_var(var_id, string) local(string_length, i, char) (
	file_var(0, var_id);
	string_length = strlen(string);
	file_var(0, string_length);
	i = 0;
	i < string_length ? while(
		char = str_getchar(string, i);
		file_var(0, char);
		i += 1;
		i < string_length;
	);
);
function write_buffer_var(var_id, buffer, length) local(i, value) (
	file_var(0, var_id);
	file_var(0, length);
	i = 0;
	i < length ? while(
		value = buffer[i];
		file_var(0, value);
		i += 1;
		i < length;
	);
);
function write_effects() local(i, effect, var_id, var_length) (
	i = 0;
	i < fx_list_count ? while(
		effect = fx_list_start + fx_list_step*i;

		var_id = VAR_ID#effect(106);
		var_length = 1; // Index
		var_length += 2 + strlen(effect[FX#NAME]);
		var_length += 2 + fx_list_statelength;
		
		file_var(0, var_id);
		file_var(0, var_length);
		debug.write_effects.var_length = var_length;
		
		file_var(0, effect[FX#SPEC_INDEX]);
		write_string_var(VAR_ID#effect_name(104), effect[FX#NAME]);
		write_buffer_var(VAR_ID#effect_state(105), effect + fx_list_headerlength, fx_list_statelength);
		
		i += 1;
		i < fx_list_count;
	);
);

// Actual logic
file_avail(0) >= 0 ? (
	debug_reset += 1;
	debug.reset_file_avail = file_avail(0);
	reset_to_defaults();
	file_avail(0) ? (
		fx_list_count = 0;
		while (
			read_var();
			file_avail(0);
		);
	);
	clear_all_notes();
	action_recompute = 1;
) : (
	write_plain_var(VAR_ID#param_width_cents(1), param_width_cents);
	write_plain_var(VAR_ID#param_attack(100), param_attack);
	write_plain_var(VAR_ID#param_decay(101), param_decay);
	write_plain_var(VAR_ID#param_sustain(102), param_sustain);
	write_plain_var(VAR_ID#param_release(103), param_release);
	write_plain_var(VAR_ID#param_env_linear(99), param_env_linear);
	write_effects();
);