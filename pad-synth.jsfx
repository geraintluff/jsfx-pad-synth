// PadSynth v1.0.0
// by Geraint Luff

desc:PadSynth (Geraint Luff)
in_pin:none;
out_pin:Left
out_pin:Right
options:want_all_kb

// v1.0.0 or above
import ui-lib.jsfx-inc

@init

// Configuration options:
// 	Feel free to change these, but you'll need to do a complete reset afterwards
// 	because many of them affect the memory layout.
options_forceduplicaterelease = 1;
options_generate_midside = 1;
options_wavetables_lowfreq = 50;
options_wavetables_highfreq = 4000;
options_wavetables_count = 18; // This is about one sample per 4 semitones
options_wavetables_samplerate = 48000; // Samples are rendered at this frequency regardless of project sample rate
options_wavetables_sampleslength = 65536; // Keeps the repetition just over a second - must be power of 2
options_polyphony = 64;

//////////////// Setup and Memory Layout ////////////////

// can_recompute = 0;
// action_recompute = 0;
// recompute_index - zero initially;
recompute_chunk = 1; // Recompute at most one waveform per block, so that we don't freeze the UI completely
polyphony = options_polyphony;
invsrate = 1/srate;

function get_waveform_name(index) (
	index == 0/*WAVEFORM:SAWTOOTH*/ ? "Sawtooth"
	: index == 1/*WAVEFORM:TRIANGLE*/ ? "Triangle"
	: index == 2/*WAVEFORM:SINE*/ ? "Sine"
	: index == 3/*WAVEFORM:SQUARE*/ ? "Square"
	: "(???)";
);
function get_warptype_name(index) (
	index == 0/*WAVEFORM_WARPTYPE:POWER*/ ? "power"
	: index == 1/*WAVEFORM_WARPTYPE:CLIP*/ ? "clip"
	: index == 2/*WAVEFORM_WARPTYPE:TANH*/ ? "tanh(x)"
	: index == 3/*WAVEFORM_WARPTYPE:SIN*/ ? "sin(x)"
	: "(???)";
);

function mag_pow(x, p) (
	x >= 0 ? pow(x, p) : -pow(-x, p);
);
function tanh(x) (
	x >= 20 ? (
		1;
	) : x <= -20 ? (
		-1;
	) : (
		(exp(2*x) - 1)/(exp(2*x) + 1);
	);
);

function atanh(x) (
	x >= 1 ? (
		100
	) : x <= -1 ? (
		-100
	) : (
		0.5*log((1 + x)/(1 - x));
	);
);

function get_waveform_value(pos) local(value, warpfactor) (
	param_waveform_mod1strength > 0 ? (
		pos = (pos + sin(pos*2*$pi + param_waveform_mod1phase)*param_waveform_mod1strength);
		while (pos > 1) (pos -= 1);
		while (pos < 0) (pos += 1);
	);

	param_waveform_type == 0/*WAVEFORM:SAWTOOTH*/ ? (
		value = (pos > 0.5) ? (pos - 1)*2 : 2*pos;
	) : param_waveform_type == 1/*WAVEFORM:TRIANGLE*/ ? (
		value = pos < 0.25 ? pos*4
		: pos < 0.75 ? 2 - pos*4
		: (pos - 1)*4;
	) : param_waveform_type == 2/*WAVEFORM:SINE*/ ? (
		value = sin(pos*2*$pi);
	) : param_waveform_type == 3/*WAVEFORM:SQUARE*/ ? (
		value = pos < 0.5 ? -1 : 1;
	) : 0;
	
	param_waveform_warpamount > 0 ? (
		warpfactor = exp(param_waveform_warpamount);
		param_waveform_warptype == 3/*WAVEFORM_WARPTYPE:SIN*/ ? (
			value = sin(asin(value)*warpfactor);
		) : param_waveform_warptype == 1/*WAVEFORM_WARPTYPE:CLIP*/ ? (
			value = max(-1, min(1, value*warpfactor));
		) : param_waveform_warptype == 0/*WAVEFORM_WARPTYPE:POWER*/ ? (
			value = 2*pow(0.5*value + 0.5, warpfactor) - 1;
		) : param_waveform_warptype == 2/*WAVEFORM_WARPTYPE:TANH*/ ? (
			value = tanh(atanh(value)*warpfactor);
		);
	);
	value;
);
function calculate_waveform_spectrum() local(i, sum, rms) (
	i = 0;
	while (i < gen_spectrum_N) (
		fftblock[i*2] = get_waveform_value(i/gen_spectrum_N);
		fftblock[i*2 + 1] = 0;
		i += 1;
	);
	fft(fftblock, gen_spectrum_N);
	fft_permute(fftblock, gen_spectrum_N);
	rms = 0;
	i = 1;
	while (i < gen_spectrum_N) (
		rms += fftblock[i*2]*fftblock[i*2];
		rms += fftblock[i*2 + 1]*fftblock[i*2 + 1];
		i += 1;
	);
	rms = sqrt(rms/gen_spectrum_N/2);
	
	i = 0;
	while (i < gen_spectrum_N) (
		sum = fftblock[i*2]*fftblock[i*2];
		sum += fftblock[i*2 + 1]*fftblock[i*2 + 1];
		gen_spectrum[i] = sqrt(sum)/rms;
		i += 1;
	);
);
function get_waveform_spectrum_amp(n) local(sum) (
	n >= gen_spectrum_N/2 ? (
		0;
	) : (
		gen_spectrum[n];
	);
);

fftblock = 0;
fft_big_working_space = fftblock + options_wavetables_sampleslength*2;
fftblock_end = fft_big_working_space + 256;

// This factorises (Cooley-Tukey) a large FFT into smaller FFTs to get around REAPER's 32768 limit.
// "working_space" must be 2*sizeB big - if you're using fft_big()
function ifft_ab(block, sizeA, sizeB, working_space)
		local(N, i, j, twiddle_amount, twiddle_r, twiddle_i, Nbits, shiftleftbits, shiftrightbits, bitmask, index1, source_index, target_index, bitmask, tmp_r, tmp_i)
		(
	N = sizeA*sizeB;

	// Permute
	Nbits = 1;
	while ((1<<Nbits) < N) (
		Nbits += 1;
	);
	shiftleftbits = 1; // This is the shift required to find the source index for a given target
	bitmask = N - 1;
	while ((1<<shiftleftbits) < sizeB) ( // NOTE: the FFT uses sizeA, the IFFT uses sizeB (inverse shift)
		shiftleftbits += 1;
	);
	shiftrightbits = Nbits - shiftleftbits;
	
	index1 = 1;
	while (index1 < N) (
		target_index = index1;
		while (
			target_index = ((target_index<<shiftleftbits)&bitmask) + (target_index>>shiftrightbits);
			target_index > index1;
		);
		target_index == index1 ? ( // This index is the shortest in its permutation group
			tmp_r = block[target_index*2];
			tmp_i = block[target_index*2 + 1];
			source_index = ((target_index<<shiftleftbits)&bitmask) + (target_index>>shiftrightbits);
			while (source_index != index1) (
				block[target_index*2] = block[source_index*2];
				block[target_index*2 + 1] = block[source_index*2 + 1];
				target_index = source_index;
				source_index = ((target_index<<shiftleftbits)&bitmask) + (target_index>>shiftrightbits);
			);
			block[target_index*2] = tmp_r;
			block[target_index*2 + 1] = tmp_i;
		);
		index1 += 1;
	);

	// Perform the in-place IFFTs
	j = 0;
	while (j < sizeB) (
		fft_ipermute(block + j*sizeA*2, sizeA);
		ifft(block + j*sizeA*2, sizeA);
		j += 1;
	);

	i = 0;
	// Perform the stepwise IFFTs
	while (i < sizeA) (
		j = 0;
		// Copy to working area, with anti-twiddle factors
		while (j < sizeB) (
			twiddle_amount = i*j/N;
			twiddle_r = cos(twiddle_amount*2*$pi);
			twiddle_i = sin(twiddle_amount*2*$pi);
			
			working_space[j*2] = block[(i + j*sizeA)*2]*twiddle_r - block[(i + j*sizeA)*2 + 1]*twiddle_i;
			working_space[j*2 + 1] = block[(i + j*sizeA)*2]*twiddle_i + block[(i + j*sizeA)*2 + 1]*twiddle_r;
			j += 1;
		);
		fft_ipermute(working_space, sizeB);
		ifft(working_space, sizeB);
		j = 0;
		while (j < sizeB) (
			block[(i + j*sizeA)*2] = working_space[j*2];
			block[(i + j*sizeA)*2 + 1] = working_space[j*2 + 1];
			j += 1;
		);

		i += 1;
	); 
);

// working_space must be 256 big (128 complex numbers), unless you're doing super-duper large (2^21 or higher) FFTs
// block and working space should not cross a 65536-boundary (well, depends on the actual size, but it's a good policy)
function ifft_big(block, N, working_space) local(sizeB) (
	N > 32768 ? (
		sizeB = 1<<7;
		(N/sizeB) > 32768 ? sizeB = 1<<11;
		(N/sizeB) > 32768 ? sizeB = 1<<13;
		ifft_ab(block, N/sizeB, sizeB, working_space);
	) : (
		fft_ipermute(block, N);
		ifft(block, N);
	);
);

gen_spectrum_N = 1024;
gen_spectrum = fftblock_end;
gen_spectrum_end = gen_spectrum + gen_spectrum_N*2;

uiblock_end = ui_setup(gen_spectrum_end);

// Description of all effects in the system
fx_spec_start = uiblock_end;
fx_spec_count = 5/*FX_SPECLIST_INDEX: */;
fx_spec_headerlength = 9/*FX_HEADER: NAME, MODCOUNT, FUNC_INIT, CONFIG_UI_FUNCTION, CONFIG_SWAP_FUNCTION, CONFIG_DELETE_FUNCTION, SETUP_NOTE_FUNCTION, PRE_EXEC_NOTE_FUNCTION, EXEC_NOTE_FUNCTION*/;
fx_spec_modlength = 3/*FX_MOD: RANGE, TYPE, NAME*/;
fx_spec_var_count = 10; // Maximum number of modulatable parameters
fx_spec_step = fx_spec_headerlength + fx_spec_modlength*fx_spec_var_count;
fx_spec_end = fx_spec_start + fx_spec_step*fx_spec_count;

fx_list_start = fx_spec_end;
//fx_list_count = 0; // Don't actually reset it here, it'll wipe all effects on playback restart!
fx_list_maxcount = 10;
fx_list_headerlength = 2/*FX: SPEC_INDEX, NAME*/;
fx_list_statelength = 16;
fx_list_step = fx_list_headerlength + fx_list_statelength;
fx_list_end = fx_list_start + fx_list_step*fx_list_maxcount;

// First N string slots are reserved for effect names
string_fx_names_start = 1; // So we don't mistake 0 for a valid index
string_fx_names_end = fx_list_maxcount;

function get_mod_range(effectIndex, modIndex) local(target_effect, target_spec, target_mod) (
	effectIndex < 0 ? (
		modIndex == 0 ? (
			0.03;
		) : modIndex == 1 ? (
			1;
		) : (
			1;
		);
	) : (
		target_effect = fx_list_start + fx_list_step*effectIndex;
		target_spec = fx_spec_start + fx_spec_step*target_effect[0/*FX:SPEC_INDEX*/];
		target_mod = target_spec + fx_spec_headerlength + fx_spec_modlength*modIndex;
		
		target_mod[0/*FX_MOD:RANGE*/];
	);
);
function get_mod_type(effectIndex, modIndex) local(target_effect, target_mod) (
	effectIndex < 0 ? (
		modIndex == 0 ? (
			0/*FX_MODTYPE:MULT*/;
		) : modIndex == 1 ? (
			0/*FX_MODTYPE:MULT*/;
		) : (
			0/*FX_MODTYPE:MULT*/;
		);
	) : (
		target_effect = fx_list_start + fx_list_step*effectIndex;
		target_spec = fx_spec_start + fx_spec_step*target_effect[0/*FX:SPEC_INDEX*/];
		target_mod = target_spec + fx_spec_headerlength + fx_spec_modlength*modIndex;
		
		target_mod[1/*FX_MOD:TYPE*/];
	);
);
function get_mod_index(effectIndex, modIndex) (
	effectIndex < 0 ? (
		modIndex == 0 ? (
			0/*NOTE:FREQ*/;
		) : modIndex == 1 ? (
			1/*NOTE:AMP*/;
		) : (
			2/*NOTE:GRANULAR_RATE*/;
		);
	) : (
		note_headerlength + note_fx_statelength*effectIndex + modIndex;
	);
);
function get_mod_name(effectIndex, modIndex) local(target_effect, target_mod) (
	effectIndex < 0 ? (
		modIndex == 0 ? (
			"Frequency";
		) : modIndex == 1 ? (
			"Amplitude";
		) : (
			"Thickness/Width";
		);
	) : (
		target_effect = fx_list_start + fx_list_step*effectIndex;
		target_spec = fx_spec_start + fx_spec_step*target_effect[0/*FX:SPEC_INDEX*/];
		target_mod = target_spec + fx_spec_headerlength + fx_spec_modlength*modIndex;
		
		target_mod[2/*FX_MOD:NAME*/];
	);
);
function get_effect_name(effectIndex) local(target_effect) (
	effectIndex < 0 ? (
		"Note"
	) : (
		target_effect = fx_list_start + fx_list_step*effectIndex;
		target_effect[1/*FX:NAME*/];
	);
);

controller_values = fx_list_end;
controller_values_end = controller_values + 128;
function reset_controllers() (
	i = 0;
	while (i < 128) (
		(i == 7 || i == 10 || (i >= 91 && i <= 95) || (i >= 70 && i <= 79) || i >= 120) ? (
			controller_values[i] = controller_values[i];
		) : (i >= 98 && i <= 101) ? (
			controller_values[i] = 1;
		) : (i != 0 && i != 32) ? (
			controller_values[i] = 0;
		);
	);
	controller_values[11] = 1;
);
function get_controller_name(index) (
	index == -2 ? (
		"Note"
	) : index == -1 ? (
		"Velocity"
	) : index == 1 ? (
		"Modulation (1)"
	) : index == 2 ? (
		"Breath (2)"
	) : index == 11 ? (
		"Expression (11)"
	) : index == 12 ? (
		"Effect 1 (12)"
	) : index == 13 ? (
		"Effect 2 (13)"
	) : index == 64 ? (
		"Sustain Pedal (64)"
	) : index == 70 ? (
		"SC-Variation (70)"
	) : index == 71 ? (
		"SC-Resonance (71)"
	) : index == 72 ? (
		"SC-Release (72)"
	) : index == 73 ? (
		"SC-Attack (73)"
	) : index == 74 ? (
		"SC-Cutoff (74)"
	) : (
		-1
	);
);
reset_controllers();

notes_start = controller_values_end;
note_headerlength = 19/*NOTE: FREQ, AMP, GRANULAR_RATE, ACTIVE, VEL, NOTE, SECONDSFROMSTART, AUDIO_LEFT, AUDIO_RIGHT, SECONDSFROMEND, DECAYRATE, CHANNEL, FREQ_BASE, AMP_BASE, WAVEINDEX_FROM, SAMPLEPOS_FROM, SAMPLEPOS_TO, GRANULAR_POS, ENV*/;

note_fx_statelength = fx_list_statelength;
notes_step = note_headerlength + note_fx_statelength*fx_list_maxcount;
notes_end = notes_start + polyphony*notes_step;
// Clear all notes
function clear_all_notes() local(note) (
	note = notes_start;
	while (
		note[3/*NOTE:ACTIVE*/] = 0;
		note += notes_step;
		note < notes_end;
	);
);
clear_all_notes();

wavetables_start = notes_end;
wavetables_count = options_wavetables_count;
wavetable_sampleslength = options_wavetables_sampleslength;
wavetable_headerlength = 2/*WAVETABLE: FREQ, WAVELENGTH*/; // Freq
wavetable_step = wavetable_headerlength + wavetable_sampleslength*2;
wavetables_end = wavetables_start + wavetables_count*wavetable_step;

display_wavetable_index = floor(wavetables_count/2);

volume_db = -12;
volume = pow(10, volume_db/20);
note_maxduration = 60*60*24*365;

wavetable_maxfreq = 18000;
wavetable_refsrate = options_wavetables_samplerate;
// 6+ octaves, centred on 440
wavetable_low = options_wavetables_lowfreq;
wavetable_high = options_wavetables_highfreq;

//////////////// LFO ////////////////

7/*LFO_NOTE_STATE: LOG_FREQ_BASE, AMP_BASE, TARGET, MODTYPE, PHASE*/ > note_fx_statelength ? ui_error("note state too small for LFO");
6/*LFO_STATE: */ > fx_list_statelength ? ui_error("effect state too small for LFO");
effectspec = fx_spec_start + fx_spec_step*0/*FX_SPECLIST_INDEX:LFO*/;
effectspec[0/*FX_HEADER:NAME*/] = "LFO";
effectspec[1/*FX_HEADER:MODCOUNT*/] = 2;
modspec = effectspec + fx_spec_headerlength + fx_spec_modlength*0/*LFO_NOTE_STATE:LOG_FREQ*/;
modspec[2/*FX_MOD:NAME*/] = "Frequency";
modspec[1/*FX_MOD:TYPE*/] = 1/*FX_MODTYPE:ADD*/;
modspec[0/*FX_MOD:RANGE*/] = 2;
modspec = effectspec + fx_spec_headerlength + fx_spec_modlength*1/*LFO_NOTE_STATE:AMP*/;
modspec[2/*FX_MOD:NAME*/] = "Amount";
modspec[1/*FX_MOD:TYPE*/] = 0/*FX_MODTYPE:MULT*/;
modspec[0/*FX_MOD:RANGE*/] = 1;

effectspec[2/*FX_HEADER:FUNC_INIT*/] = 1/*effect_init_lfo*/;
function effect_init_lfo(effect) local(state) (
	effect[1/*FX:NAME*/] = "LFO Modulator";
	
	state = effect + fx_list_headerlength;
	state[0/*LFO_STATE:MOD_EFFECT*/] = -1; // Initial target: note itself
	state[1/*LFO_STATE:MOD_INDEX*/] = 1; // Note amplitude
	
	state[3/*LFO_STATE:FREQ*/] = 5; // Freq
	state[4/*LFO_STATE:AMP*/] = 0.5; // Amp
	state[5/*LFO_STATE:PHASE_START*/] = 0; // Negative means "random", positive is phase
);
effectspec[3/*FX_HEADER:CONFIG_UI_FUNCTION*/] = 1/*effect_ui_lfo*/;
function effect_ui_lfo(effect) local(state, effect_index, mod_range) (
	effect_index = (effect - fx_list_start)/fx_list_step;
	state = effect + fx_list_headerlength;

	mod_range = get_mod_range(state[0/*LFO_STATE:MOD_EFFECT*/], state[1/*LFO_STATE:MOD_INDEX*/]);
	ui_split_topratio(1/4);
		ui_push_heighttext(-1);
			ui_split_leftratio(0.2);
				ui_align(1, -1);
				ui_padright();
				ui_text("depth");
			ui_pop();
			ui_split_rightratio(0.2);
				ui_padleft();
				ui_align(0, -1);
				ui_textnumber(floor(state[4/*LFO_STATE:AMP*/]*100/mod_range + 0.5), "%i%%");
			ui_pop();
			state[4/*LFO_STATE:AMP*/] = control_hslider(state[4/*LFO_STATE:AMP*/], 0, mod_range*2, 3);
		ui_pop();
	ui_split_next();
		ui_push_heighttext(-1);
			ui_split_leftratio(0.2);
				ui_padright();
				ui_align(1, -1);
				ui_text("frequency");
			ui_pop();
			ui_split_rightratio(0.2);
				ui_padleft();
				ui_align(0, -1);
				ui_textnumber(state[3/*LFO_STATE:FREQ*/], "%.2fHz");
			ui_pop();
			state[3/*LFO_STATE:FREQ*/] = control_hslider(state[3/*LFO_STATE:FREQ*/], 0, 100, 3);
		ui_pop();
	ui_split_next();
		ui_push_heighttext(-1);
			ui_split_leftratio(0.2);
				ui_padright();
				ui_align(1, -1);
				ui_text("phase");
			ui_pop();
			ui_split_rightratio(0.2);
			ui_pop();
			ui_split_lefttext("constant");
				control_button(state[5/*LFO_STATE:PHASE_START*/] >= 0 ? "constant" : "random") ? (
					state[5/*LFO_STATE:PHASE_START*/] >= 0 ? (
						state[5/*LFO_STATE:PHASE_START*/] = -1;
					) : (
						state[5/*LFO_STATE:PHASE_START*/] = 0;
					);
				);
			ui_pop();
			
			ui_padleft();
			state[5/*LFO_STATE:PHASE_START*/] >= 0 ? (
				state[5/*LFO_STATE:PHASE_START*/] = control_hslider(state[5/*LFO_STATE:PHASE_START*/], 0, 2*$pi, 0);
			);
		ui_pop();
	ui_split_next();
		ui_push_heighttext(-1);
			ui_split_leftratio(0.2);
				ui_align(1, -1);
				ui_padright();
				ui_text("target");
			ui_pop();
			ui_split_rightratio(0.2);
				ui_padleft();
				ui_padright();
				control_button("edit") ? (
					ui_screen_open("automation-target");
					ui_screen_set(0, state + 0/*LFO_STATE:MOD_EFFECT*/);
					ui_screen_set(1, state + 1/*LFO_STATE:MOD_INDEX*/);
					ui_screen_set(2, state + 4/*LFO_STATE:AMP*/);
					ui_screen_set(3, effect_index);
				);
			ui_pop();
			ui_split_leftratio(0.6);
				ui_padright();
				control_readout(get_effect_name(state[0/*LFO_STATE:MOD_EFFECT*/]));
			ui_split_next();
				control_readout(get_mod_name(state[0/*LFO_STATE:MOD_EFFECT*/], state[1/*LFO_STATE:MOD_INDEX*/]));
			ui_pop();
		ui_pop();
	ui_pop();
);
effectspec[4/*FX_HEADER:CONFIG_SWAP_FUNCTION*/] = 1/*effect_swap_lfo*/;
function effect_swap_lfo(effect, fxIndex1, fxIndex2) (
	state = effect + fx_list_headerlength;

	state[0/*LFO_STATE:MOD_EFFECT*/] == fxIndex1 ? (
		state[0/*LFO_STATE:MOD_EFFECT*/] = fxIndex2;
	) : state[0/*LFO_STATE:MOD_EFFECT*/] == fxIndex2 ? (
		state[0/*LFO_STATE:MOD_EFFECT*/] = fxIndex1;
	);
);
effectspec[5/*FX_HEADER:CONFIG_DELETE_FUNCTION*/] = 1/*effect_delete_lfo*/;
function effect_delete_lfo(effect, fxIndex) (
	state = effect + fx_list_headerlength;

	state[0/*LFO_STATE:MOD_EFFECT*/] == fxIndex ? (
		// Our target was just deleted - reset the effect
		effect_init_lfo(effect);
		// Amplitude to zero
		state[4/*LFO_STATE:AMP*/] = 0;
	);
);
effectspec[6/*FX_HEADER:SETUP_NOTE_FUNCTION*/] = 1/*effect_note_setup_lfo*/;
function effect_note_setup_lfo(effect, note, notestate) local(state) (
	state = effect + fx_list_headerlength;
	// Two modulatable parameters

	notestate[2/*LFO_NOTE_STATE:LOG_FREQ_BASE*/] = log(state[3/*LFO_STATE:FREQ*/]); // freq
	notestate[3/*LFO_NOTE_STATE:AMP_BASE*/] = state[4/*LFO_STATE:AMP*/]; // amp
	
	// Use the remainder for private state
	notestate[4/*LFO_NOTE_STATE:TARGET*/] = get_mod_index(state[0/*LFO_STATE:MOD_EFFECT*/], state[1/*LFO_STATE:MOD_INDEX*/]);
	notestate[5/*LFO_NOTE_STATE:MODTYPE*/] = get_mod_type(state[0/*LFO_STATE:MOD_EFFECT*/],
	state[1/*LFO_STATE:MOD_INDEX*/]);
	notestate[6/*LFO_NOTE_STATE:PHASE*/] = (state[5/*LFO_STATE:PHASE_START*/] >= 0) ? (
		state[5/*LFO_STATE:PHASE_START*/];
	) : (
		rand(2*$pi);
	);
);
effectspec[7/*FX_HEADER:PRE_EXEC_NOTE_FUNCTION*/] = 1/*effect_note_pre_exec_lfo*/;
function effect_note_pre_exec_lfo(effect, note, notestate) (
	notestate[1/*LFO_NOTE_STATE:AMP*/] = notestate[3/*LFO_NOTE_STATE:AMP_BASE*/];
	notestate[0/*LFO_NOTE_STATE:LOG_FREQ*/] = notestate[2/*LFO_NOTE_STATE:LOG_FREQ_BASE*/];
);
effectspec[8/*FX_HEADER:EXEC_NOTE_FUNCTION*/] = 1/*effect_note_exec_lfo*/;
function effect_note_exec_lfo(effect, note, notestate) local(angFreq, value, targetIndex) (
	targetIndex = notestate[4/*LFO_NOTE_STATE:TARGET*/];
	targetIndex >= 0 ? (
		angFreq = 2*$pi*exp(notestate[0/*LFO_NOTE_STATE:LOG_FREQ*/])*invsrate;
		notestate[6/*LFO_NOTE_STATE:PHASE*/] += angFreq;
		value = notestate[1/*LFO_NOTE_STATE:AMP*/]*sin(notestate[6/*LFO_NOTE_STATE:PHASE*/]);
		notestate[5/*LFO_NOTE_STATE:MODTYPE*/] == 1/*FX_MODTYPE:ADD*/ ? (
			note[targetIndex] += value;
		) : (
			note[targetIndex] *= max(0, 1 + value);
		);
	);
);

//////////////// Filter ////////////////

16/*FILTER_NOTE_STATE: LOG_FREQ_BASE, Q_BASE, ATTACK_AMOUNT_BASE, ATTACK_TIME_BASE, X1_L, X2_L, Y1_L, Y2_L, X1_R, X2_R, Y1_R, Y2_R*/ > note_fx_statelength ? ui_error("note state too small for filter");
7/*FILTER_STATE: ATTACK_AMOUNT_VELOCITY, FREQ_LOG_VELOCITY, FREQ_LOG_NOTE*/ > fx_list_statelength ? ui_error("effect state too small for filter");
effectspec = fx_spec_start + fx_spec_step*1/*FX_SPECLIST_INDEX:FILTER*/;
effectspec[0/*FX_HEADER:NAME*/] = "Filter";
effectspec[1/*FX_HEADER:MODCOUNT*/] = 4;
modspec = effectspec + fx_spec_headerlength + fx_spec_modlength*0/*FILTER_NOTE_STATE:LOG_FREQ*/;
modspec[2/*FX_MOD:NAME*/] = "Frequency";
modspec[1/*FX_MOD:TYPE*/] = 1/*FX_MODTYPE:ADD*/;
modspec[0/*FX_MOD:RANGE*/] = 4;
modspec = effectspec + fx_spec_headerlength + fx_spec_modlength*1/*FILTER_NOTE_STATE:Q*/;
modspec[2/*FX_MOD:NAME*/] = "Q-Factor";
modspec[1/*FX_MOD:TYPE*/] = 0/*FX_MODTYPE:MULT*/;
modspec[0/*FX_MOD:RANGE*/] = 1;
modspec = effectspec + fx_spec_headerlength + fx_spec_modlength*2/*FILTER_NOTE_STATE:ATTACK_AMOUNT*/;
modspec[2/*FX_MOD:NAME*/] = "Attack (start)";
modspec[1/*FX_MOD:TYPE*/] = 1/*FX_MODTYPE:ADD*/;
modspec[0/*FX_MOD:RANGE*/] = 2;
modspec = effectspec + fx_spec_headerlength + fx_spec_modlength*3/*FILTER_NOTE_STATE:ATTACK_TIME*/;
modspec[2/*FX_MOD:NAME*/] = "Attack (time)";
modspec[1/*FX_MOD:TYPE*/] = 0/*FX_MODTYPE:MULT*/;
modspec[0/*FX_MOD:RANGE*/] = 1;

effectspec[2/*FX_HEADER:FUNC_INIT*/] = 2/*effect_init_filter*/;
function effect_init_filter(effect) local(state) (
	effect[1/*FX:NAME*/] = "Filter";
	
	state = effect + fx_list_headerlength;
	state[0/*FILTER_STATE:FREQ*/] = 1000;
	state[1/*FILTER_STATE:Q*/] = 2;
	state[2/*FILTER_STATE:ATTACK_AMOUNT*/] = 0;
	state[3/*FILTER_STATE:ATTACK_TIME*/] = 0.1;

	// Private state
	state[4/*FILTER_STATE:ATTACK_AMOUNT_VELOCITY*/] = log(10);
	state[5/*FILTER_STATE:FREQ_LOG_VELOCITY*/] = log(5);
	state[6/*FILTER_STATE:FREQ_LOG_NOTE*/] = 0.5;
);
effectspec[3/*FX_HEADER:CONFIG_UI_FUNCTION*/] = 2/*effect_ui_filter*/;
function effect_ui_filter(effect) local(state, effect_index, mod_range) (
	effect_index = (effect - fx_list_start)/fx_list_step;
	state = effect + fx_list_headerlength;

	ui_split_topratio(3/5);
		control_group("Filter");
		ui_split_topratio(1/4);
			ui_push_heighttext(-1);
				ui_split_leftratio(0.2);
					ui_align(1, -1);
					ui_padright();
					ui_text("Freq");
				ui_pop();
				ui_split_rightratio(0.2);
					ui_padleft();
					ui_align(0, -1);
					ui_textnumber(floor(state[0/*FILTER_STATE:FREQ*/] + 0.5), "%iHz");
				ui_pop();
				state[0/*FILTER_STATE:FREQ*/] = control_hslider(state[0/*FILTER_STATE:FREQ*/], 20, 18000, log(18000/20));
			ui_pop();
		ui_split_next();
			ui_push_heighttext(-1);
				ui_split_leftratio(0.2);
					ui_align(1, -1);
					ui_padright();
					ui_text("Q");
				ui_pop();
				ui_split_rightratio(0.2);
					ui_padleft();
					ui_align(0, -1);
					ui_textnumber(state[1/*FILTER_STATE:Q*/], "%0.1f");
				ui_pop();
				state[1/*FILTER_STATE:Q*/] = control_hslider(state[1/*FILTER_STATE:Q*/], 0.1, 10, 3);
			ui_pop();
		ui_split_next();
			ui_push_heighttext(-1);
				ui_split_leftratio(0.2);
					ui_align(1, -1);
					ui_padright();
					ui_text("Velocity");
				ui_pop();
				ui_split_rightratio(0.2);
					ui_padleft();
					ui_align(0, -1);
					ui_textnumber(exp(state[5/*FILTER_STATE:FREQ_LOG_VELOCITY*/]), "x%0.2f");
				ui_pop();
				state[5/*FILTER_STATE:FREQ_LOG_VELOCITY*/] = control_hslider(state[5/*FILTER_STATE:FREQ_LOG_VELOCITY*/], 0, log(20), -1);
			ui_pop();
		ui_split_next();
			ui_push_heighttext(-1);
				ui_split_leftratio(0.2);
					ui_align(1, -1);
					ui_padright();
					ui_text("Note");
				ui_pop();
				ui_split_rightratio(0.2);
					ui_padleft();
					ui_align(0, -1);
					ui_textnumber(floor(state[6/*FILTER_STATE:FREQ_LOG_NOTE*/]*100 + 0.5), "%i%%");
				ui_pop();
				state[6/*FILTER_STATE:FREQ_LOG_NOTE*/] = control_hslider(state[6/*FILTER_STATE:FREQ_LOG_NOTE*/], -1, 2, 0);
			ui_pop();
		ui_pop();
	ui_split_next();
		control_group("Envelope");
		ui_split_topratio(1/3);
			ui_push_heighttext(-1);
				ui_split_leftratio(0.2);
					ui_align(1, -1);
					ui_padright();
					ui_text("Attack");
				ui_pop();
				ui_split_rightratio(0.2);
					ui_padleft();
					ui_align(0, -1);
					ui_textnumber(state[3/*FILTER_STATE:ATTACK_TIME*/]*1000, "%ims");
				ui_pop();
				state[3/*FILTER_STATE:ATTACK_TIME*/] = control_hslider(state[3/*FILTER_STATE:ATTACK_TIME*/], 0.001, 1.5, 3);
			ui_pop();
		ui_split_next();
			ui_push_heighttext(-1);
				ui_split_leftratio(0.2);
					ui_align(1, -1);
					ui_padright();
					ui_text("Start");
				ui_pop();
				ui_split_rightratio(0.2);
					ui_padleft();
					ui_align(0, -1);
					ui_textnumber(exp(state[2/*FILTER_STATE:ATTACK_AMOUNT*/]), "x%0.2f");
				ui_pop();
				state[2/*FILTER_STATE:ATTACK_AMOUNT*/] = control_hslider(state[2/*FILTER_STATE:ATTACK_AMOUNT*/], -5, 5, 0);
			ui_pop();
		ui_split_next();
			ui_push_heighttext(-1);
				ui_split_leftratio(0.2);
					ui_align(1, -1);
					ui_padright();
					ui_text("Velocity");
				ui_pop();
				ui_split_rightratio(0.2);
					ui_padleft();
					ui_align(0, -1);
					ui_textnumber(exp(state[4/*FILTER_STATE:ATTACK_AMOUNT_VELOCITY*/]), "x%0.2f");
				ui_pop();
				state[4/*FILTER_STATE:ATTACK_AMOUNT_VELOCITY*/] = control_hslider(state[4/*FILTER_STATE:ATTACK_AMOUNT_VELOCITY*/], 0, log(20), -1);
			ui_pop();
		ui_pop();
	ui_pop();
);
effectspec[4/*FX_HEADER:CONFIG_SWAP_FUNCTION*/] = 0;
effectspec[5/*FX_HEADER:CONFIG_DELETE_FUNCTION*/] = 0;
effectspec[6/*FX_HEADER:SETUP_NOTE_FUNCTION*/] = 2/*effect_note_setup_filter*/;
function effect_note_setup_filter(effect, note, notestate) local(state) (
	state = effect + fx_list_headerlength;

	// Four modulatable parameters
	notestate[4/*FILTER_NOTE_STATE:LOG_FREQ_BASE*/] = log(state[0/*FILTER_STATE:FREQ*/]);
	notestate[4/*FILTER_NOTE_STATE:LOG_FREQ_BASE*/] += state[5/*FILTER_STATE:FREQ_LOG_VELOCITY*/]*(note[4/*NOTE:VEL*/] - 64)/127;
	notestate[4/*FILTER_NOTE_STATE:LOG_FREQ_BASE*/] += state[6/*FILTER_STATE:FREQ_LOG_NOTE*/]*(note[5/*NOTE:NOTE*/] - 64)*log(2)/12;
	notestate[5/*FILTER_NOTE_STATE:Q_BASE*/] = state[1/*FILTER_STATE:Q*/];
	notestate[6/*FILTER_NOTE_STATE:ATTACK_AMOUNT_BASE*/] = state[2/*FILTER_STATE:ATTACK_AMOUNT*/];
	notestate[6/*FILTER_NOTE_STATE:ATTACK_AMOUNT_BASE*/] += state[4/*FILTER_STATE:ATTACK_AMOUNT_VELOCITY*/]*note[4/*NOTE:VEL*/]/127;
	notestate[7/*FILTER_NOTE_STATE:ATTACK_TIME_BASE*/] = state[3/*FILTER_STATE:ATTACK_TIME*/];
	
	// Private state
	notestate[8/*FILTER_NOTE_STATE:X1_L*/] = 0;
	notestate[9/*FILTER_NOTE_STATE:X2_L*/] = 0;
	notestate[10/*FILTER_NOTE_STATE:Y1_L*/] = 0;
	notestate[11/*FILTER_NOTE_STATE:Y2_L*/] = 0;
	
	notestate[12/*FILTER_NOTE_STATE:X1_R*/] = 0;
	notestate[13/*FILTER_NOTE_STATE:X2_R*/] = 0;
	notestate[14/*FILTER_NOTE_STATE:Y1_R*/] = 0;
	notestate[15/*FILTER_NOTE_STATE:Y2_R*/] = 0;
);
effectspec[7/*FX_HEADER:PRE_EXEC_NOTE_FUNCTION*/] = 2/*effect_note_pre_exec_filter*/;
function effect_note_pre_exec_filter(effect, note, notestate) (
	notestate[0/*FILTER_NOTE_STATE:LOG_FREQ*/] = notestate[4/*FILTER_NOTE_STATE:LOG_FREQ_BASE*/];
	notestate[1/*FILTER_NOTE_STATE:Q*/] = notestate[5/*FILTER_NOTE_STATE:Q_BASE*/];
	notestate[2/*FILTER_NOTE_STATE:ATTACK_AMOUNT*/] = notestate[6/*FILTER_NOTE_STATE:ATTACK_AMOUNT_BASE*/];
	notestate[3/*FILTER_NOTE_STATE:ATTACK_TIME*/] = notestate[7/*FILTER_NOTE_STATE:ATTACK_TIME_BASE*/];
);
effectspec[8/*FX_HEADER:EXEC_NOTE_FUNCTION*/] = 2/*effect_note_exec_filter*/;
function effect_note_exec_filter(effect, note, notestate) local(logfreq, freq, Q, w0, cosW0, alpha, a0, a1, a2, b0, b1, b2, x, y) (
	logfreq = notestate[0/*FILTER_NOTE_STATE:LOG_FREQ*/];
	note[6/*NOTE:SECONDSFROMSTART*/] < notestate[3/*FILTER_NOTE_STATE:ATTACK_TIME*/] ? (
		logfreq += notestate[2/*FILTER_NOTE_STATE:ATTACK_AMOUNT*/]*(1 - note[6/*NOTE:SECONDSFROMSTART*/]/notestate[3/*FILTER_NOTE_STATE:ATTACK_TIME*/]);
	);
	freq = exp(logfreq);
	Q = notestate[1/*FILTER_NOTE_STATE:Q*/];
	Q < 0.1 ? Q = 0.1;

	w0 = 2*$pi*min(0.49, freq/srate);
	cosW0 = cos(w0);
	alpha = sin(w0)/(2*Q);
	
	a0 = 1 + alpha;
	a1 = (-2*cosW0)/a0;
	a2 = (1 - alpha)/a0;
	b1 = (1 - cosW0)/a0;
	b0 = b1/2;
	b2 = b0;
	
	x = note[7/*NOTE:AUDIO_LEFT*/];
	y = b0*x + b1*notestate[8/*FILTER_NOTE_STATE:X1_L*/] + b2*notestate[9/*FILTER_NOTE_STATE:X2_L*/]
		- a1*notestate[10/*FILTER_NOTE_STATE:Y1_L*/] - a2*notestate[11/*FILTER_NOTE_STATE:Y2_L*/];
	notestate[9/*FILTER_NOTE_STATE:X2_L*/] = notestate[8/*FILTER_NOTE_STATE:X1_L*/];
	notestate[8/*FILTER_NOTE_STATE:X1_L*/] = x;
	notestate[11/*FILTER_NOTE_STATE:Y2_L*/] = notestate[10/*FILTER_NOTE_STATE:Y1_L*/];
	notestate[10/*FILTER_NOTE_STATE:Y1_L*/] = note[7/*NOTE:AUDIO_LEFT*/] = y;
		
	x = note[8/*NOTE:AUDIO_RIGHT*/];
	y = b0*x + b1*notestate[12/*FILTER_NOTE_STATE:X1_R*/] + b2*notestate[13/*FILTER_NOTE_STATE:X2_R*/]
		- a1*notestate[14/*FILTER_NOTE_STATE:Y1_R*/] - a2*notestate[15/*FILTER_NOTE_STATE:Y2_R*/];
	notestate[13/*FILTER_NOTE_STATE:X2_R*/] = notestate[12/*FILTER_NOTE_STATE:X1_R*/];
	notestate[12/*FILTER_NOTE_STATE:X1_R*/] = x;
	notestate[15/*FILTER_NOTE_STATE:Y2_R*/] = notestate[14/*FILTER_NOTE_STATE:Y1_R*/];
	notestate[14/*FILTER_NOTE_STATE:Y1_R*/] = note[8/*NOTE:AUDIO_RIGHT*/] = y;
);

//////////////// Controller Mod ////////////////

8/*CONMOD_NOTE_STATE: TARGET, MODTYPE, SOURCE, AMOUNT, CURVE_POWER, OFFSET, VALUE, SLEWFACTOR*/ > note_fx_statelength ? ui_error("note state too small for controller mod");
7/*CONMOD_STATE: AMP*/ > fx_list_statelength ? ui_error("effect state too small for controller mod");
effectspec = fx_spec_start + fx_spec_step*2/*FX_SPECLIST_INDEX:CONMOD*/;
effectspec[0/*FX_HEADER:NAME*/] = "Controller/Note/Vel";
effectspec[1/*FX_HEADER:MODCOUNT*/] = 0;

effectspec[2/*FX_HEADER:FUNC_INIT*/] = 3/*effect_init_conmod*/;
function effect_init_conmod(effect) local(state) (
	effect[1/*FX:NAME*/] = "Control/Note/Vel Modulator";
	
	state = effect + fx_list_headerlength;
	state[0/*CONMOD_STATE:MOD_EFFECT*/] = -1; // Initial target: note itself
	state[1/*CONMOD_STATE:MOD_INDEX*/] = 0; // Frequency
	
	state[2/*CONMOD_STATE:SOURCE*/] = -1; // -2 is note, -1 is velocity
	state[3/*CONMOD_STATE:AMOUNT*/] = 0.015;
	state[4/*CONMOD_STATE:ZERO_POINT*/] = 0.5;
	state[5/*CONMOD_STATE:CURVE*/] = 0;
);
effectspec[3/*FX_HEADER:CONFIG_UI_FUNCTION*/] = 3/*effect_ui_conmod*/;
function effect_conmod_curve(value, zero_point, curve) local(curvepower) (
	curvepower = exp(curve);
	pow(value, curvepower) - pow(zero_point, curvepower);
);
function effect_ui_conmod(effect) local(state, effect_index, mod_range, source, source_name, name, source_prev, source_next, i, value, y) (
	effect_index = (effect - fx_list_start)/fx_list_step;
	state = effect + fx_list_headerlength;

	mod_range = get_mod_range(state[0/*CONMOD_STATE:MOD_EFFECT*/], state[1/*CONMOD_STATE:MOD_INDEX*/]);
	ui_split_topratio(1/9);
		ui_push_heighttext(-1);
			ui_split_leftratio(0.2);
				ui_align(1, -1);
				ui_padright();
				ui_text("source");
			ui_pop();
			ui_split_rightratio(0.2);
			ui_pop();

			source = state[2/*CONMOD_STATE:SOURCE*/];
			source_prev = -2;
			source_next = source;
			i = -2;
			while (i < 128) (
				name = get_controller_name(i);
				name >= 0 ? (
					i == source ? (
						source_name = name;
					);
					i < source ? source_prev = i;
					i > source ? (
						source_next = i;
						i = 128;
					);
				);
				i += 1;
			);
			ui_align(0, -1);
			state[2/*CONMOD_STATE:SOURCE*/] = control_selector(source, source_name, source_next, source_prev);
		ui_pop();
	ui_split_next();
		ui_push_heighttext(-1);
			ui_split_leftratio(0.2);
				ui_align(1, -1);
				ui_padright();
				ui_text("depth");
			ui_pop();
			ui_split_rightratio(0.2);
				ui_padleft();
				ui_align(0, -1);
				ui_textnumber(floor(state[3/*CONMOD_STATE:AMOUNT*/]*100/mod_range + 0.5), "%i%%");
			ui_pop();
			state[3/*CONMOD_STATE:AMOUNT*/] = control_hslider(state[3/*CONMOD_STATE:AMOUNT*/], 0, mod_range*2, 3);
		ui_pop();
	ui_split_next();
		ui_push_heighttext(-1);
			ui_split_leftratio(0.2);
				ui_padright();
				ui_align(1, -1);
				ui_text("zero point");
			ui_pop();
			ui_split_rightratio(0.2);
				ui_padleft();
				ui_align(0, -1);
				ui_textnumber(state[4/*CONMOD_STATE:ZERO_POINT*/]*127, "%i");
			ui_pop();
			state[4/*CONMOD_STATE:ZERO_POINT*/] = control_hslider(state[4/*CONMOD_STATE:ZERO_POINT*/], 0, 1, 0);
		ui_pop();
	ui_split_next();
		ui_push_heighttext(-1);
			ui_split_leftratio(0.2);
				ui_padright();
				ui_align(1, -1);
				ui_text("curve");
			ui_pop();
			ui_split_rightratio(0.2);
			ui_pop();
			state[5/*CONMOD_STATE:CURVE*/] = control_hslider(state[5/*CONMOD_STATE:CURVE*/], -2, 2, 0);
		ui_pop();
	ui_split_next();
		ui_push_heighttext(-1);
			ui_split_leftratio(0.2);
				ui_align(1, -1);
				ui_padright();
				ui_text("target");
			ui_pop();
			ui_split_rightratio(0.2);
				ui_padleft();
				ui_padright();
				control_button("edit") ? (
					ui_screen_open("automation-target");
					ui_screen_set(0, state + 0/*CONMOD_STATE:MOD_EFFECT*/);
					ui_screen_set(1, state + 1/*CONMOD_STATE:MOD_INDEX*/);
					ui_screen_set(2, state + 3/*CONMOD_STATE:AMOUNT*/);
					ui_screen_set(3, effect_index);
				);
			ui_pop();
			ui_split_leftratio(0.6);
				ui_padright();
				control_readout(get_effect_name(state[0/*CONMOD_STATE:MOD_EFFECT*/]));
			ui_split_next();
				control_readout(get_mod_name(state[0/*CONMOD_STATE:MOD_EFFECT*/], state[1/*CONMOD_STATE:MOD_INDEX*/]));
			ui_pop();
		ui_pop();
	ui_pop();
	
	ui_color(0, 0, 0);
	ui_fill();
	ui_colora(255, 255, 255, 0.8);
	gfx_line(ui_left(), ui_top() + ui_height()/2, ui_right(), ui_top() + ui_height()/2);

	ui_color(128, 192, 255);
	gfx_x = ui_left();
	i = 0;
	while (i <= 127) (
		value = effect_conmod_curve(i/127, state[4/*CONMOD_STATE:ZERO_POINT*/], state[5/*CONMOD_STATE:CURVE*/]);
		y = ui_bottom() - ui_height()*(1 + value)/2;
		i > 0 ? (
			gfx_lineto(ui_left() + ui_width()*i/127, y, 1);
		) : (
			gfx_y = y;
		);
		i += 1;
	);
	
	ui_color(0, 0, 0);
	ui_border();
	control_finish_enabled(1);
);
effectspec[4/*FX_HEADER:CONFIG_SWAP_FUNCTION*/] = 2/*effect_swap_conmod*/;
function effect_swap_conmod(effect, fxIndex1, fxIndex2) (
	state = effect + fx_list_headerlength;

	state[0/*CONMOD_STATE:MOD_EFFECT*/] == fxIndex1 ? (
		state[0/*CONMOD_STATE:MOD_EFFECT*/] = fxIndex2;
	) : state[0/*CONMOD_STATE:MOD_EFFECT*/] == fxIndex2 ? (
		state[0/*CONMOD_STATE:MOD_EFFECT*/] = fxIndex1;
	);
);
effectspec[5/*FX_HEADER:CONFIG_DELETE_FUNCTION*/] = 2/*effect_delete_conmod*/;
function effect_delete_conmod(effect, fxIndex) (
	state = effect + fx_list_headerlength;

	state[0/*CONMOD_STATE:MOD_EFFECT*/] == fxIndex ? (
		// Our target was just deleted - reset the effect
		effect_init_conmod(effect);
		// Amplitude to zero
		state[6/*CONMOD_STATE:AMP*/] = 0;
	);
);
effectspec[6/*FX_HEADER:SETUP_NOTE_FUNCTION*/] = 3/*effect_note_setup_conmod*/;
function effect_note_setup_conmod(effect, note, notestate) local(state) (
	state = effect + fx_list_headerlength;
	
	// Use the remainder for private state
	notestate[0/*CONMOD_NOTE_STATE:TARGET*/] = get_mod_index(state[0/*CONMOD_STATE:MOD_EFFECT*/], state[1/*CONMOD_STATE:MOD_INDEX*/]);
	notestate[1/*CONMOD_NOTE_STATE:MODTYPE*/] = get_mod_type(state[0/*CONMOD_STATE:MOD_EFFECT*/],
	state[1/*CONMOD_STATE:MOD_INDEX*/]);
	
	notestate[2/*CONMOD_NOTE_STATE:SOURCE*/] = state[2/*CONMOD_STATE:SOURCE*/];
	notestate[3/*CONMOD_NOTE_STATE:AMOUNT*/] = state[3/*CONMOD_STATE:AMOUNT*/];

	notestate[4/*CONMOD_NOTE_STATE:CURVE_POWER*/] = exp(state[5/*CONMOD_STATE:CURVE*/]);
	notestate[5/*CONMOD_NOTE_STATE:OFFSET*/] = pow(state[4/*CONMOD_STATE:ZERO_POINT*/], notestate[4/*CONMOD_NOTE_STATE:CURVE_POWER*/]);
	
	notestate[6/*CONMOD_NOTE_STATE:VALUE*/] = -1;
	notestate[7/*CONMOD_NOTE_STATE:SLEWFACTOR*/] = 1/0.005/srate;
);
effectspec[7/*FX_HEADER:PRE_EXEC_NOTE_FUNCTION*/] = 0;
effectspec[8/*FX_HEADER:EXEC_NOTE_FUNCTION*/] = 3/*effect_note_exec_conmod*/;
function effect_note_exec_conmod(effect, note, notestate) local(source, value, targetIndex) (
	targetIndex = notestate[0/*CONMOD_NOTE_STATE:TARGET*/];
	source = notestate[2/*CONMOD_NOTE_STATE:SOURCE*/];
	targetIndex >= 0 ? (
		value = (source == -1) ? note[4/*NOTE:VEL*/]/127 : (source == -2) ? note[5/*NOTE:NOTE*/]/127 : controller_values[source];
		value = notestate[3/*CONMOD_NOTE_STATE:AMOUNT*/]*2*(pow(value, notestate[4/*CONMOD_NOTE_STATE:CURVE_POWER*/]) - notestate[5/*CONMOD_NOTE_STATE:OFFSET*/]);
		notestate[6/*CONMOD_NOTE_STATE:VALUE*/] < 0 ? (
			notestate[6/*CONMOD_NOTE_STATE:VALUE*/] = value;
		) : (
			value = notestate[6/*CONMOD_NOTE_STATE:VALUE*/] = notestate[6/*CONMOD_NOTE_STATE:VALUE*/] + (value - notestate[6/*CONMOD_NOTE_STATE:VALUE*/])*notestate[7/*CONMOD_NOTE_STATE:SLEWFACTOR*/];
		);
		notestate[1/*CONMOD_NOTE_STATE:MODTYPE*/] == 1/*FX_MODTYPE:ADD*/ ? (
			note[targetIndex] += value;
		) : (
			note[targetIndex] *= max(0, 1 + value);
		);
	);
);

//////////////// Distortion ////////////////

1/*DIST_NOTE_STATE: */ > note_fx_statelength ? ui_error("note state too small for distortion");
5/*DIST_STATE: */ > fx_list_statelength ? ui_error("effect state too small for distortion");
effectspec = fx_spec_start + fx_spec_step*3/*FX_SPECLIST_INDEX:DISTORTION*/;
effectspec[0/*FX_HEADER:NAME*/] = "Distortion";
effectspec[1/*FX_HEADER:MODCOUNT*/] = 1;
modspec = effectspec + fx_spec_headerlength + fx_spec_modlength*0/*DIST_NOTE_STATE:WET*/;
modspec[2/*FX_MOD:NAME*/] = "Wet";
modspec[1/*FX_MOD:TYPE*/] = 0/*FX_MODTYPE:MULT*/;
modspec[0/*FX_MOD:RANGE*/] = 1;

effectspec[2/*FX_HEADER:FUNC_INIT*/] = 4/*effect_init_dist*/;
function effect_init_dist(effect) local(state) (
	effect[1/*FX:NAME*/] = "Distortion";
	state = effect + fx_list_headerlength;

	state[0/*DIST_STATE:LIMIT_LOG*/] = log(0.25);
	state[1/*DIST_STATE:CURVE*/] = 0/*DIST_CURVE:TANH*/;
	state[2/*DIST_STATE:ASYMMETRY*/] = 0;
	state[3/*DIST_STATE:POST_AMP_LOG*/] = 0;
	state[4/*DIST_STATE:WET*/] = 0.75;
);
effectspec[3/*FX_HEADER:CONFIG_UI_FUNCTION*/] = 4/*effect_ui_dist*/;
function effect_ui_dist(effect) local(state, effect_index, mod_range, i, value, preGain, postGain, asymmetry, tanh_asymmetry) (
	effect_index = (effect - fx_list_start)/fx_list_step;
	state = effect + fx_list_headerlength;

	ui_split_top(ui_texth() + ui_hpadding()*3);
		ui_push_heighttext(-1);
			ui_split_leftratio(0.2);
				ui_align(1, -1);
				ui_padright();
				ui_text("limit");
			ui_pop();
			ui_split_rightratio(0.2);
				ui_padleft();
				ui_align(0, -1);
				ui_textnumber(state[0/*DIST_STATE:LIMIT_LOG*/]*20/log(10), "%0.1fdB");
			ui_pop();
			state[0/*DIST_STATE:LIMIT_LOG*/] = control_hslider(state[0/*DIST_STATE:LIMIT_LOG*/], -4, 0, -1);
		ui_pop();
	ui_split_next();
		ui_push_heighttext(-1);
			ui_split_leftratio(0.2);
				ui_align(1, -1);
				ui_padright();
				ui_text("asymmetry");
			ui_pop();
			ui_split_rightratio(0.2);
				ui_padleft();
				ui_align(0, -1);
				ui_textnumber(tanh(state[2/*DIST_STATE:ASYMMETRY*/])*100, "%i%%");
			ui_pop();
			state[2/*DIST_STATE:ASYMMETRY*/] = control_hslider(state[2/*DIST_STATE:ASYMMETRY*/], 0, 3, 3);
		ui_pop();
	ui_split_next();
		ui_push_heighttext(-1);
			ui_split_leftratio(0.2);
				ui_align(1, -1);
				ui_padright();
				ui_text("post-amp");
			ui_pop();
			ui_split_rightratio(0.2);
				ui_padleft();
				ui_align(0, -1);
				ui_textnumber(state[3/*DIST_STATE:POST_AMP_LOG*/]*20/log(10), "%0.1fdB");
			ui_pop();
			state[3/*DIST_STATE:POST_AMP_LOG*/] = control_hslider(state[3/*DIST_STATE:POST_AMP_LOG*/], 0, 2, 0);
		ui_pop();
	ui_split_next();
		ui_push_heighttext(-1);
			ui_split_leftratio(0.2);
				ui_align(1, -1);
				ui_padright();
				ui_text("wet");
			ui_pop();
			ui_split_rightratio(0.2);
				ui_padleft();
				ui_align(0, -1);
				ui_textnumber(state[4/*DIST_STATE:WET*/]*100, "%i%%");
			ui_pop();
			state[4/*DIST_STATE:WET*/] = control_hslider(state[4/*DIST_STATE:WET*/], 0, 1, 0);
		ui_pop();
	ui_pop();
	
	ui_color(0, 0, 0);
	ui_fill();
	ui_colora(255, 255, 255, 0.5);
	gfx_line(ui_left(), ui_top() + ui_height()/2, ui_right(), ui_top() + ui_height()/2);
	
	preGain = exp(-state[0/*DIST_STATE:LIMIT_LOG*/]);
	postGain = exp(state[3/*DIST_STATE:POST_AMP_LOG*/] + state[0/*DIST_STATE:LIMIT_LOG*/]);
	asymmetry = state[2/*DIST_STATE:ASYMMETRY*/];
	tanh_asymmetry = tanh(asymmetry);

	ui_color(128, 192, 256);
	i = 1;
	gfx_x = ui_left();
	value = -1;
	value += (postGain*(tanh(preGain*-1 + asymmetry) - tanh_asymmetry) - value)*state[4/*DIST_STATE:WET*/];
	value = max(-1, min(1, value));
	gfx_y = ui_bottom() - (1 + value)*0.5*ui_height();
	while (i <= 1000) (
		value = (i/1000)*2 - 1;
		value += (postGain*(tanh(preGain*value + asymmetry) - tanh_asymmetry) - value)*state[4/*DIST_STATE:WET*/];
		value = max(-1, min(1, value));
		gfx_lineto(ui_left() + (i/1000)*ui_width(), ui_bottom() - (1 + value)*0.5*ui_height());
		i += 1;
	);
	control_finish_enabled(1);
);
effectspec[4/*FX_HEADER:CONFIG_SWAP_FUNCTION*/] = 0;
effectspec[5/*FX_HEADER:CONFIG_DELETE_FUNCTION*/] = 0;
effectspec[6/*FX_HEADER:SETUP_NOTE_FUNCTION*/] = 4/*effect_note_setup_dist*/;
function effect_note_setup_dist(effect, note, notestate) local(state) (
	state = effect + fx_list_headerlength;
);
effectspec[7/*FX_HEADER:PRE_EXEC_NOTE_FUNCTION*/] = 3/*effect_note_pre_exec_dist*/;
function effect_note_pre_exec_dist(effect, note, notestate) (
	state = effect + fx_list_headerlength;
	notestate[0/*DIST_NOTE_STATE:WET*/] = state[4/*DIST_STATE:WET*/];
);
effectspec[8/*FX_HEADER:EXEC_NOTE_FUNCTION*/] = 4/*effect_note_exec_dist*/;
function effect_note_exec_dist(effect, note, notestate) local(asymmetry, tanh_asymmetry, wet, preGain, postGain) (
	state = effect + fx_list_headerlength;

	preGain = exp(-state[0/*DIST_STATE:LIMIT_LOG*/]);
	postGain = exp(state[3/*DIST_STATE:POST_AMP_LOG*/] + state[0/*DIST_STATE:LIMIT_LOG*/]);

	wet = min(1, notestate[0/*DIST_NOTE_STATE:WET*/]);
	asymmetry = state[2/*DIST_STATE:ASYMMETRY*/];
	asymmetry ? (
		tanh_asymmetry = tanh(asymmetry);
		note[7/*NOTE:AUDIO_LEFT*/] += (postGain*(tanh(preGain*note[7/*NOTE:AUDIO_LEFT*/] + asymmetry) - tanh_asymmetry) - note[7/*NOTE:AUDIO_LEFT*/])*wet;
		note[8/*NOTE:AUDIO_RIGHT*/] += (postGain*(tanh(preGain*note[8/*NOTE:AUDIO_RIGHT*/] + asymmetry) - tanh_asymmetry) - note[8/*NOTE:AUDIO_RIGHT*/])*wet;
	) : (
		note[7/*NOTE:AUDIO_LEFT*/] += (postGain*tanh(preGain*note[7/*NOTE:AUDIO_LEFT*/]) - note[7/*NOTE:AUDIO_LEFT*/])*wet;
		note[8/*NOTE:AUDIO_RIGHT*/] += (postGain*tanh(preGain*note[8/*NOTE:AUDIO_RIGHT*/]) - note[8/*NOTE:AUDIO_RIGHT*/])*wet;
	);
);

//////////////// FM ////////////////

4/*FM_STATE: */ > fx_list_statelength ? ui_error("effect state too small for FM");
5/*FM_NOTE_STATE: AMP_BASE, OFFSET_HZ_BASE, PHASE*/ > note_fx_statelength ? ui_error("note state too small for FM");
effectspec = fx_spec_start + fx_spec_step*4/*FX_SPECLIST_INDEX:FM*/;
effectspec[0/*FX_HEADER:NAME*/] = "Harmonic Modulator (FM)";
effectspec[1/*FX_HEADER:MODCOUNT*/] = 2;
modspec = effectspec + fx_spec_headerlength + fx_spec_modlength*0/*FM_NOTE_STATE:AMP*/;
modspec[2/*FX_MOD:NAME*/] = "Amount";
modspec[1/*FX_MOD:TYPE*/] = 0/*FX_MODTYPE:MULT*/;
modspec[0/*FX_MOD:RANGE*/] = 1;
modspec = effectspec + fx_spec_headerlength + fx_spec_modlength*1/*FM_NOTE_STATE:OFFSET_HZ*/;
modspec[2/*FX_MOD:NAME*/] = "Offset (Hz)";
modspec[1/*FX_MOD:TYPE*/] = 1/*FX_MODTYPE:ADD*/;
modspec[0/*FX_MOD:RANGE*/] = 10;

effectspec[2/*FX_HEADER:FUNC_INIT*/] = 5/*effect_init_fm*/;
function effect_init_fm(effect) local(state) (
	effect[1/*FX:NAME*/] = "Harmonic Modulator (FM)";
	
	state = effect + fx_list_headerlength;
	state[0/*FM_STATE:HARMONIC_CENTER*/] = 1; // Average freq will be multiple of base freq
	state[1/*FM_STATE:HARMONIC_CYCLES*/] = 1; // How many freq-mod cycles per wavelength
	state[2/*FM_STATE:AMP*/] = 0.5; // Between 0 and 1
	state[3/*FM_STATE:OFFSET_HZ*/] = 0; // Harmonic frequency will be above/below by this much
);
effectspec[3/*FX_HEADER:CONFIG_UI_FUNCTION*/] = 5/*effect_ui_fm*/;
function effect_ui_fm(effect) local(state, effect_index, mod_range) (
	effect_index = (effect - fx_list_start)/fx_list_step;
	state = effect + fx_list_headerlength;

	ui_split_topratio(1/4);
		ui_push_heighttext(-1);
			ui_split_leftratio(0.2);
				ui_align(1, -1);
				ui_padright();
				ui_text("harmonic");
			ui_pop();
			ui_split_rightratio(0.2);
				ui_padleft();
				ui_align(0, -1);
				ui_textnumber(state[0/*FM_STATE:HARMONIC_CENTER*/], "%0.1f");
			ui_pop();
			state[0/*FM_STATE:HARMONIC_CENTER*/] = control_hslider(state[0/*FM_STATE:HARMONIC_CENTER*/], 0, 2, 0);
			state[0/*FM_STATE:HARMONIC_CENTER*/] = max(0.5, floor(state[0/*FM_STATE:HARMONIC_CENTER*/]*2 + 0.5)/2);
		ui_pop();
	ui_split_next();
		ui_push_heighttext(-1);
			ui_split_leftratio(0.2);
				ui_padright();
				ui_align(1, -1);
				ui_text("modulation");
			ui_pop();
			ui_split_rightratio(0.2);
				ui_padleft();
				ui_align(0, -1);
				ui_textnumber(state[1/*FM_STATE:HARMONIC_CYCLES*/], "%0.1f");
			ui_pop();
			state[1/*FM_STATE:HARMONIC_CYCLES*/] = control_hslider(state[1/*FM_STATE:HARMONIC_CYCLES*/], 0, 5, 0);
			state[1/*FM_STATE:HARMONIC_CYCLES*/] = max(0.5, floor(state[1/*FM_STATE:HARMONIC_CYCLES*/]*2 + 0.5)/2);
		ui_pop();
	ui_split_next();
		ui_push_heighttext(-1);
			ui_split_leftratio(0.2);
				ui_padright();
				ui_align(1, -1);
				ui_text("range");
			ui_pop();
			ui_split_rightratio(0.2);
				ui_padleft();
				ui_align(0, -1);
				ui_textnumber(state[2/*FM_STATE:AMP*/]*100, "%i%%");
			ui_pop();
			state[2/*FM_STATE:AMP*/] = control_hslider(state[2/*FM_STATE:AMP*/], 0, 5, 0);
		ui_pop();
	ui_split_next();
		ui_push_heighttext(-1);
			ui_split_leftratio(0.2);
				ui_padright();
				ui_align(1, -1);
				ui_text("offset");
			ui_pop();
			ui_split_rightratio(0.2);
				ui_padleft();
				ui_align(0, -1);
				ui_textnumber(state[3/*FM_STATE:OFFSET_HZ*/], "%0.1fHz");
			ui_pop();
			state[3/*FM_STATE:OFFSET_HZ*/] = mag_pow(control_hslider(mag_pow(state[3/*FM_STATE:OFFSET_HZ*/], 1/3), -5, 5, 0), 3);
		ui_pop();
	ui_pop();
);
effectspec[4/*FX_HEADER:CONFIG_SWAP_FUNCTION*/] = 0;
effectspec[5/*FX_HEADER:CONFIG_DELETE_FUNCTION*/] = 0;
effectspec[6/*FX_HEADER:SETUP_NOTE_FUNCTION*/] = 5/*effect_note_setup_fm*/;
function effect_note_setup_fm(effect, note, notestate) local(state) (
	state = effect + fx_list_headerlength;
	// Two modulatable parameters

	notestate[2/*FM_NOTE_STATE:AMP_BASE*/] = state[2/*FM_STATE:AMP*/];
	notestate[3/*FM_NOTE_STATE:OFFSET_HZ_BASE*/] = state[3/*FM_STATE:OFFSET_HZ*/];
	
	// Use the remainder for private state
	notestate[4/*FM_NOTE_STATE:PHASE*/] = rand(2*$pi);
);
effectspec[7/*FX_HEADER:PRE_EXEC_NOTE_FUNCTION*/] = 4/*effect_note_pre_exec_fm*/;
function effect_note_pre_exec_fm(effect, note, notestate) (
	notestate[0/*FM_NOTE_STATE:AMP*/] = notestate[2/*FM_NOTE_STATE:AMP_BASE*/];
	notestate[1/*FM_NOTE_STATE:OFFSET_HZ*/] = notestate[3/*FM_NOTE_STATE:OFFSET_HZ_BASE*/];
);
effectspec[8/*FX_HEADER:EXEC_NOTE_FUNCTION*/] = 5/*effect_note_exec_fm*/;
function effect_note_exec_fm(effect, note, notestate) local(freq, phase, modfreq, amp) (
	state = effect + fx_list_headerlength;

	amp = notestate[0/*FM_NOTE_STATE:AMP*/];
	freq = note[0/*NOTE:FREQ*/];
	phase = notestate[4/*FM_NOTE_STATE:PHASE*/];
	phase += (freq*state[1/*FM_STATE:HARMONIC_CYCLES*/] + notestate[1/*FM_NOTE_STATE:OFFSET_HZ*/])*2*$pi*invsrate;
	modfreq = freq*state[0/*FM_STATE:HARMONIC_CENTER*/]*(1 + sin(phase)*amp);
	note[0/*NOTE:FREQ*/] = modfreq;
	
	phase > $pi ? phase -= 2*$pi;
	notestate[4/*FM_NOTE_STATE:PHASE*/] = phase;
);

//////////////// Effect Manipulation ////////////////

function effect_init(function_id, effect_slot) (
	function_id ? (
		function_id == 1 ? effect_init_lfo(effect_slot)
		: function_id == 2 ? effect_init_filter(effect_slot)
		: function_id == 3 ? effect_init_conmod(effect_slot)
		: function_id == 4 ? effect_init_dist(effect_slot)
		: function_id == 5 ? effect_init_fm(effect_slot)
	);
);;
function config_ui(function_id, effect) (
	function_id ? (
		function_id == 1 ? effect_ui_lfo(effect)
		: function_id == 2 ? effect_ui_filter(effect)
		: function_id == 3 ? effect_ui_conmod(effect)
		: function_id == 4 ? effect_ui_dist(effect)
		: function_id == 5 ? effect_ui_fm(effect)
	);
);;
function config_swap(function_id, effect, index1, index2) (
	function_id ? (
		function_id == 1 ? effect_swap_lfo(effect, index1, index2)
		: function_id == 2 ? effect_swap_conmod(effect, index1, index2)
	);
);;
function config_delete(function_id, effect, index) (
	function_id ? (
		function_id == 1 ? effect_delete_lfo(effect, index)
		: function_id == 2 ? effect_delete_conmod(effect, index)
	);
);;
function note_setup(function_id, effect, note, notestate) (
	function_id ? (
		function_id == 1 ? effect_note_setup_lfo(effect, note, notestate)
		: function_id == 2 ? effect_note_setup_filter(effect, note, notestate)
		: function_id == 3 ? effect_note_setup_conmod(effect, note, notestate)
		: function_id == 4 ? effect_note_setup_dist(effect, note, notestate)
		: function_id == 5 ? effect_note_setup_fm(effect, note, notestate)
	);
);;
function note_exec(function_id, effect, note, notestate) (
	function_id ? (
		function_id == 1 ? effect_note_exec_lfo(effect, note, notestate)
		: function_id == 2 ? effect_note_exec_filter(effect, note, notestate)
		: function_id == 3 ? effect_note_exec_conmod(effect, note, notestate)
		: function_id == 4 ? effect_note_exec_dist(effect, note, notestate)
		: function_id == 5 ? effect_note_exec_fm(effect, note, notestate)
	);
);;
function note_pre_exec(function_id, effect, note, notestate) (
	function_id ? (
		function_id == 1 ? effect_note_pre_exec_lfo(effect, note, notestate)
		: function_id == 2 ? effect_note_pre_exec_filter(effect, note, notestate)
		: function_id == 3 ? effect_note_pre_exec_dist(effect, note, notestate)
		: function_id == 4 ? effect_note_pre_exec_fm(effect, note, notestate)
	);
);;

function append_effect(index) local(spec, effect, effect_name) (
	fx_list_count < fx_list_maxcount ? (
		// TODO: check the index is valid, otherwise insert placeholder (negative index)
		effect = fx_list_start + fx_list_step*fx_list_count;
		effect_name = string_fx_names_start + fx_list_count;
		spec = fx_spec_start + fx_spec_step*index;
		effect_init(spec[2/*FX_HEADER:FUNC_INIT*/], effect);
		effect[0/*FX:SPEC_INDEX*/] = index;
	

		// Make sure effect is using the correct mutable string slot
		effect[1/*FX:NAME*/] != effect_name ? (
			strcpy(effect_name, effect[1/*FX:NAME*/]);
			effect[1/*FX:NAME*/] = effect_name;
		);
		
		clear_all_notes();
		fx_list_count += 1;
		clear_all_notes();

		fx_list_count - 1; // Index before increment
	) : -1;
);
function effect_swap(fxIndex1, fxIndex2) local(note, i, tmp, effect, effect2, spec) (
	// Swap the headers (copy the string values, don't swap references)
	effect = fx_list_start + fx_list_step*fxIndex1;
	effect2 = fx_list_start + fx_list_step*fxIndex2;
	strcpy(#effect_swap_tmp, effect[1/*FX:NAME*/]);
	strcpy(effect[1/*FX:NAME*/], effect2[1/*FX:NAME*/]);
	strcpy(effect2[1/*FX:NAME*/], #effect_swap_tmp);
	
	tmp = effect[0/*FX:SPEC_INDEX*/];
	effect[0/*FX:SPEC_INDEX*/] = effect2[0/*FX:SPEC_INDEX*/];
	effect2[0/*FX:SPEC_INDEX*/] = tmp;
	
	// Swap the states
	i = 0;
	while (i < fx_list_statelength) (
		tmp = (effect + fx_list_headerlength)[i];
		(effect + fx_list_headerlength)[i] = (effect2 + fx_list_headerlength)[i];
		(effect2 + fx_list_headerlength)[i] = tmp;
		i += 1;
	);

	i = 0;
	while (i < fx_list_count) (
		effect = fx_list_start + fx_list_step*i;
		spec = fx_spec_start + fx_spec_step*effect[0/*FX:SPEC_INDEX*/];
		config_swap(spec[4/*FX_HEADER:CONFIG_SWAP_FUNCTION*/], effect, fxIndex1, fxIndex2);
		i += 1;
	);
	
	// Stop all notes, because their internal state is now in the wrong order
	clear_all_notes();
);
function effect_delete(fxIndex) local(i, effect, spec) (
	fx_list_count > 0 && fxIndex >= 0 && fxIndex < fx_list_count ? (
		while (fxIndex < fx_list_count - 1) (
			effect_swap(fxIndex, fxIndex + 1);
			fxIndex += 1;
		);
		fx_list_count -= 1;

		i = 0;
		while (i < fx_list_count) (
			effect = fx_list_start + fx_list_step*i;
			spec = fx_spec_start + fx_spec_step*effect[0/*FX:SPEC_INDEX*/];
			config_delete(spec[5/*FX_HEADER:CONFIG_DELETE_FUNCTION*/], effect, fx_list_count);
			i += 1;
		);
	) : (
		ui_error("Invalid effect deletion");
	);
);

function reset_to_defaults() (
	action_recompute = 1;
	can_recompute = 1;
	has_set_parameters = 1;

	param_waveform_type = 0;
	param_waveform_warptype = 0;
	param_waveform_warpamount = 0;
	param_waveform_mod1strength = 0;
	param_waveform_mod1phase = 0;
	param_width_cents = 20;
	param_attack = 0.01;
	param_decay = 0.3;
	param_sustain = 0.75;
	param_release = 0.03;
	param_env_linear = 0;

	fx_list_count = 0;
);
!has_set_parameters ? reset_to_defaults();

srate != prev_srate ? (
	prev_srate = srate;
	action_recompute = 1;
	clear_all_notes();
);

@block

//////////////// Compute Samples ////////////////

action_recompute ? (
	can_recompute = 0;
	action_recompute = 0;
	recompute_index = 0;
);

action_recalculate_spectrum ? (
	calculate_waveform_spectrum();
	action_recalculate_spectrum = 0;
);

recompute_index < wavetables_count ? (
	param_width = param_width_cents/1200*log(2);
	wavetable_index = recompute_index;
	recompute_stop_index = min(wavetables_count, recompute_index + recompute_chunk);
	
	calculate_waveform_spectrum();
	while (
		ratio = (wavetable_index + 0.5)/wavetables_count;
		base_freq = exp(log(wavetable_low) + log(wavetable_high/wavetable_low)*ratio);
		// Zero it out
		i = 0;
		while (
			fftblock[i] = 0;
			i += 1;
			i < wavetable_sampleslength*2;
		);
		
		harmonic_range_factor = exp(param_width*2);
		i = 1;
		while (
			power = 0;
			indexfreq = i/wavetable_sampleslength*wavetable_refsrate;
			indexwidth = log((i + 1)/i);
			harmonic_freq = base_freq*floor(indexfreq/base_freq/harmonic_range_factor);
			end_freq = min(wavetable_maxfreq, indexfreq*harmonic_range_factor);
			while (
				harmonic_index = floor(harmonic_freq/base_freq + 0.5);
				harmonic_amp = get_waveform_spectrum_amp(harmonic_index);
				harmonic_power = harmonic_amp*harmonic_amp;
				log_width = max(indexwidth, param_width);
				hz_width = exp(log_width)*harmonic_freq;
				stddistance = log(indexfreq/harmonic_freq)*2/log_width;
				power += harmonic_power/hz_width*exp(-stddistance*stddistance); // Gaussian

				harmonic_freq += base_freq;
				harmonic_freq < end_freq;
			);
			amp = sqrt(power);
			phase1 = rand(2*$pi);
			phase2 = rand(2*$pi);
	
			leftR = amp*cos(phase1);
			leftI = amp*sin(phase1);
			rightR = amp*cos(phase2);
			rightI = amp*sin(phase2);
			
			i2 = wavetable_sampleslength - i;
			fftblock[2*i] = leftR - rightI;
			fftblock[2*i + 1] = leftI + rightR;
			fftblock[2*i2] = leftR + rightI;
			fftblock[2*i2 + 1] = rightR - leftI;

			i += 1;
			i < wavetable_sampleslength/2;
		);
		
		// IFFT

		ifft_big(fftblock, wavetable_sampleslength, fft_big_working_space);

		// Normalise two channels separately
		sum2 = 0;
		i = 0;
		while (i < wavetable_sampleslength) (
			sum2 += fftblock[2*i]*fftblock[2*i];
			i += 1;
		);
		factor1 = 0.25/sqrt(sum2/wavetable_sampleslength);

		sum2 = 0;
		i = 0;
		while (i < wavetable_sampleslength) (
			sum2 += fftblock[2*i + 1]*fftblock[2*i + 1];
			i += 1;
		);
		factor2 = 0.25/sqrt(sum2/wavetable_sampleslength);

		// Place in wavetable
		wavetable = wavetables_start + wavetable_step*wavetable_index;
		wavetable[0/*WAVETABLE:FREQ*/] = base_freq*srate/wavetable_refsrate;
		wavetable[1/*WAVETABLE:WAVELENGTH*/] = wavetable_refsrate/base_freq;
		wavetable_samples = wavetable + wavetable_headerlength;
		assignedwavetable = wavetable;
		i = 0;
		while (i < wavetable_sampleslength) (
			left = fftblock[2*i]*factor1;
			right = fftblock[2*i + 1]*factor2;
			options_generate_midside ? (
				mid = left/sqrt(2);
				side = right/sqrt(2);
				left = mid + side;
				right = mid - side;
			);
			wavetable_samples[2*i] = left;
			wavetable_samples[2*i + 1] = right;
			i += 1;
		);
		
		wavetable_index += 1;
		wavetable_index < recompute_stop_index;
	);
	recompute_index = wavetable_index;
);

//////////////// Parse MIDI Events ////////////////

while (midirecv(midi_offset, midi_msg1, midi_msg23)) (
	midisend(midi_offset, midi_msg1, midi_msg23); // passthrough
	midi_type = midi_msg1>>4;
	midi_channel = midi_msg1&0x0f;
	midi_msg2 = midi_msg23&$xff; // note / controller
	midi_msg3 = midi_msg23>>8; // velocity / value
	(midi_type == $x9 && midi_msg3 != 0) ? (
		// Note on
		options_forceduplicaterelease ? (
			note = notes_start;
			while (note < notes_end) (
				note[3/*NOTE:ACTIVE*/] && (note[5/*NOTE:NOTE*/] == midi_msg2) ? (
					// Force release of duplicate notes
					note[9/*NOTE:SECONDSFROMEND*/] = max(note[9/*NOTE:SECONDSFROMEND*/], -midi_offset*invsrate);
					note[10/*NOTE:DECAYRATE*/] = 1;
				);
				note += notes_step;
			);
		);
		note = notes_start;
		while (note[3/*NOTE:ACTIVE*/] && note < notes_end) (
			note += notes_step;
		);
		// Found a free slot
		note < notes_end ? (
			// Note parameters
			note[3/*NOTE:ACTIVE*/] = 1;
			note[11/*NOTE:CHANNEL*/] = midi_channel;
			note[5/*NOTE:NOTE*/] = midi_msg2;
			note[4/*NOTE:VEL*/] = midi_msg3;
			note[6/*NOTE:SECONDSFROMSTART*/] = -midi_offset*invsrate;
			note[9/*NOTE:SECONDSFROMEND*/] = -note_maxduration - midi_offset*invsrate;
			note[10/*NOTE:DECAYRATE*/] = 0;
			note[12/*NOTE:FREQ_BASE*/] = 440*pow(2, (note[5/*NOTE:NOTE*/] - 69)/12);
			note[13/*NOTE:AMP_BASE*/] = volume*note[4/*NOTE:VEL*/]/127;
			
			// Wavetable params
			wavetable_index = log(note[12/*NOTE:FREQ_BASE*/]/wavetable_low)/log(wavetable_high/wavetable_low)*wavetables_count;
			wavetable_index = min(wavetables_count - 1, max(0, floor(wavetable_index)));
			note[14/*NOTE:WAVEINDEX_FROM*/] = wavetable_index; // Wavetable #0
			note[15/*NOTE:SAMPLEPOS_FROM*/] = rand(wavetable_sampleslength);
			note[16/*NOTE:SAMPLEPOS_TO*/] = note[15/*NOTE:SAMPLEPOS_FROM*/];
			note[17/*NOTE:GRANULAR_POS*/] = 1;
			
			// FX note setup
			i = 0;
			i < fx_list_count ? while (
				effect = fx_list_start + i*fx_list_step;
				spec = fx_spec_start + fx_spec_step*effect[0/*FX:SPEC_INDEX*/];
				notestate = note + note_headerlength + note_fx_statelength*i;

				note_setup(spec[6/*FX_HEADER:SETUP_NOTE_FUNCTION*/], effect, note, notestate);

				i += 1;
				i < fx_list_count;
			);
		);
	) : (midi_type == $x8 || (midi_type == $x9 && midi_msg3 == 0)) ? (
		// Note off 
		note = notes_start;
		while (
			note[3/*NOTE:ACTIVE*/] && note[11/*NOTE:CHANNEL*/] == midi_channel && note[5/*NOTE:NOTE*/] == midi_msg2 ? (
				note[9/*NOTE:SECONDSFROMEND*/] = max(note[9/*NOTE:SECONDSFROMEND*/], -midi_offset*invsrate);
			);
			note += notes_step;
			note < notes_end;
		);
	) : (midi_type == 11) ? (
		midi_msg2 == 121 ? (
			reset_controllers();
		) : midi_msg == 123 ? (
			note = notes_start;
			while (note < notes_end) (
				note[3/*NOTE:ACTIVE*/] ? (
					note[9/*NOTE:SECONDSFROMEND*/] = 0;
				);
				note += note_step;
			);
		) : midi_msg == 120 ? (
			clear_all_notes();
		) : (
			controller_values[midi_msg2] = midi_msg3/127;
		);
	);
);

polyphony_current = 0;
note = notes_start;
note_active_end = notes_start;
while (
	note[3/*NOTE:ACTIVE*/] ? (
		polyphony_current += 1;
		note_active_end = note + notes_step;
	);
	note += notes_step;
	note < notes_end;
);

@sample

//////////////// Sampler ////////////////

note = notes_start;
while (
	note[3/*NOTE:ACTIVE*/] ? (
		secondsFromStart = note[6/*NOTE:SECONDSFROMSTART*/];
		secondsFromEnd = note[9/*NOTE:SECONDSFROMEND*/];

		secondsFromStart > 0 ? (
			note[0/*NOTE:FREQ*/] = note[12/*NOTE:FREQ_BASE*/];
			note[1/*NOTE:AMP*/] = note[13/*NOTE:AMP_BASE*/];
			note[2/*NOTE:GRANULAR_RATE*/] = 1;

			// Sample from waveforms
			wavetable = wavetables_start + note[14/*NOTE:WAVEINDEX_FROM*/]*wavetable_step;
			wavetable_freq = wavetable[0/*WAVETABLE:FREQ*/];
			wavetable_samples = wavetable + wavetable_headerlength;
			midsample = note[15/*NOTE:SAMPLEPOS_FROM*/];
			lowsample = floor(midsample);
			highsample = ceil(midsample)%wavetable_sampleslength;
			ratio = (midsample - lowsample);

			lowvalue = wavetable_samples[2*lowsample];
			highvalue = wavetable_samples[2*highsample];
			note[7/*NOTE:AUDIO_LEFT*/] = lowvalue + (highvalue - lowvalue)*ratio;

			lowvalue = wavetable_samples[2*lowsample + 1];
			highvalue = wavetable_samples[2*highsample + 1];
			note[8/*NOTE:AUDIO_RIGHT*/] = lowvalue + (highvalue - lowvalue)*ratio;
			
			granular_ratio = note[17/*NOTE:GRANULAR_POS*/];
			granular_ratio ? (
				debug.span = note[16/*NOTE:SAMPLEPOS_TO*/] - note[15/*NOTE:SAMPLEPOS_FROM*/];

				// Second sample value
				midsample = note[16/*NOTE:SAMPLEPOS_TO*/];
				lowsample = floor(midsample);
				highsample = ceil(midsample)%wavetable_sampleslength;
				ratio = (midsample - lowsample);
				
				lowvalue = wavetable_samples[2*lowsample];
				highvalue = wavetable_samples[2*highsample];
				note[7/*NOTE:AUDIO_LEFT*/] = (lowvalue + (highvalue - lowvalue)*ratio)*granular_ratio + note[7/*NOTE:AUDIO_LEFT*/]*(1 - granular_ratio);

				lowvalue = wavetable_samples[2*lowsample + 1];
				highvalue = wavetable_samples[2*highsample + 1];
				note[8/*NOTE:AUDIO_RIGHT*/] = (lowvalue + (highvalue - lowvalue)*ratio)*granular_ratio + note[8/*NOTE:AUDIO_RIGHT*/]*(1 - granular_ratio);
			);

			env = 1;
			stretch = param_env_linear ? 1 : 1;
			attack = param_attack;
			decay = param_decay*stretch;
			sustain = param_sustain;
			release = param_release*stretch;

			secondsFromStart < attack ? (
				env *= secondsFromStart/attack;
			) : (
				secondsFromAttack = secondsFromStart - attack;
				secondsFromAttack < decay ? (
					env *= sustain + (1 - sustain)*(
						param_env_linear
							? 1 - secondsFromAttack/decay
							: pow(1 - secondsFromAttack/decay, 3)
					);
				) : (
					env *= sustain;
				);
			);
			secondsFromEnd > 0 ? (
				secondsFromEnd > release ? (
					env = 0;
					note[3/*NOTE:ACTIVE*/] = 0;
				) : (
					env *= param_env_linear
						? 1 - secondsFromEnd/release
						: pow(1 - secondsFromEnd/release, 3);
				);
			);
			note[18/*NOTE:ENV*/] = env;

			// FX note parameter reset
			i = 0;
			while (i < fx_list_count) (
				effect = fx_list_start + i*fx_list_step;
				spec = fx_spec_start + fx_spec_step*effect[0/*FX:SPEC_INDEX*/];
				notestate = note + note_headerlength + note_fx_statelength*i;

				note_pre_exec(spec[7/*FX_HEADER:PRE_EXEC_NOTE_FUNCTION*/], effect, note, notestate);
				i += 1;
			);
			// FX note setup
			i = 0;
			while (i < fx_list_count) (
				effect = fx_list_start + i*fx_list_step;
				spec = fx_spec_start + fx_spec_step*effect[0/*FX:SPEC_INDEX*/];
				notestate = note + note_headerlength + note_fx_statelength*i;

				note_exec(spec[8/*FX_HEADER:EXEC_NOTE_FUNCTION*/], effect, note, notestate);
				i += 1;
			);

			// Increment position using frequency
			freqRatio = note[0/*NOTE:FREQ*/]/wavetable_freq;

			granular_rate = note[2/*NOTE:GRANULAR_RATE*/] - 1;
			granular_ratio += freqRatio*abs(granular_rate)/wavetable[1/*WAVETABLE:WAVELENGTH*/];
			while (granular_ratio >= 1) (
				granular_ratio -= 1;
				note[15/*NOTE:SAMPLEPOS_FROM*/] = note[16/*NOTE:SAMPLEPOS_TO*/];
				granular_rate > 0 ? (
					note[16/*NOTE:SAMPLEPOS_TO*/] += wavetable[1/*WAVETABLE:WAVELENGTH*/];
				) : (
					note[16/*NOTE:SAMPLEPOS_TO*/] -= wavetable[1/*WAVETABLE:WAVELENGTH*/];
				);
			);
			note[17/*NOTE:GRANULAR_POS*/] = granular_ratio;

			midsample = note[15/*NOTE:SAMPLEPOS_FROM*/] + freqRatio;
			while (midsample < 0) (
				midsample += wavetable_sampleslength;
			);
			while (midsample > wavetable_sampleslength) (
				midsample -= wavetable_sampleslength;
			);
			note[15/*NOTE:SAMPLEPOS_FROM*/] = midsample;

			midsample = note[16/*NOTE:SAMPLEPOS_TO*/] + freqRatio;
			while (midsample < 0) (
				midsample += wavetable_sampleslength;
			);
			while (midsample > wavetable_sampleslength) (
				midsample -= wavetable_sampleslength;
			);
			note[16/*NOTE:SAMPLEPOS_TO*/] = midsample;
			
			spl0 += note[7/*NOTE:AUDIO_LEFT*/]*note[1/*NOTE:AMP*/]*env;
			spl1 += note[8/*NOTE:AUDIO_RIGHT*/]*note[1/*NOTE:AMP*/]*env;
		);

		note[6/*NOTE:SECONDSFROMSTART*/] += invsrate;
		secondsFromEnd >= 0 ? (
			note[10/*NOTE:DECAYRATE*/] = max(1 - controller_values[64], note[10/*NOTE:DECAYRATE*/]);
			note[9/*NOTE:SECONDSFROMEND*/] += invsrate*note[10/*NOTE:DECAYRATE*/];
		) : (
			note[9/*NOTE:SECONDSFROMEND*/] += invsrate;
		);
	);
	note += notes_step;
	note < note_active_end;
);

@gfx 580 460

//////////////// Graphics ////////////////

function draw_waveform() local(wavetable, samples, value, x, y, gi, gis, box_left, box_top, box_width, box_height) (
	box_left = ui_left();
	box_top = ui_top();
	box_width = ui_width();
	box_height = ui_height();

	wavetable = wavetables_start + display_wavetable_index*wavetable_step;
	samples = wavetable + wavetable_headerlength;
	gis = ceil(wavetable_sampleslength*0.25/box_width);
	// Left - blue
	gi = 0;
	gfx_r = 0.25;
	gfx_g = 0.5;
	gfx_b = 0.75;
	gfx_x = box_left;
	gfx_y = ui_top() + box_height/2;
	while (
		value = min(1, max(-1, samples[gi*2]));
		x = box_left + gi/wavetable_sampleslength*box_width;
		y = box_top + 0.5*(1 - value)*box_height;
		gfx_lineto(x, y, 0);
		gi += 1;
		gi < wavetable_sampleslength;
	);
	// Right - orange
	gi = 0;
	gfx_r = 0.75;
	gfx_g = 0.5;
	gfx_b = 0.25;
	gfx_a = 1;
	gfx_x = box_left;
	gfx_y = box_top + box_height/2;
	while (
		value = min(1, max(-1, samples[gi*2 + 1]));
		x = box_left + gi/wavetable_sampleslength*box_width;
		y = box_top + 0.5*(1 - value)*box_height;
		gfx_lineto(x, y, 0);
		gi += 1;
		gi < wavetable_sampleslength;
	);
	ui_color(0, 0, 0);
	ui_border();
);

ui_start("main"); // Default screen

slider_value = slider_value ? slider_value : 0.5;

ui_screen() == "main" ? (
	control_navbar("PadSynth", "About", "about");
	ui_pad();
	ui_split_toptext("");
		ui_split_leftratio(1/3);
			control_button("Waveform") ? (
				ui_screen_open("waveform");
			);
		ui_split_next();
			control_button("Envelope") ? (
				ui_screen_open("envelope");
			);
		ui_split_next();
			display_first_effect = fx_list_start;
			control_button("Effects") ? (
				ui_screen_open("list-effects");
			);
		ui_pop();
	ui_pop();
	ui_padtop();
	
	ui_split_bottomtext("");
		ui_split_righttext("Regenerate");
			control_indicator_button("Regenerate", can_recompute) ? (
				can_recompute ? action_recompute = 1;
			);
		ui_pop();
	
		ui_split_lefttext("Width (cents)");
			ui_text("Width (cents)");
		ui_pop();
		ui_split_righttext("200");
			ui_padleft();
			ui_align(0, -1);
			ui_textnumber(param_width_cents + 0.5, "%i");
		ui_pop();

		new_width_cents = control_hslider(param_width_cents, 5, 200, 3);
		new_width_cents != param_width_cents ? can_recompute = 1;
		param_width_cents = new_width_cents;
	ui_pop();
	ui_padbottom();
	
	ui_push();
		ui_color(0, 0, 0);
		ui_fill();
		draw_waveform();
		ui_push();
			ui_pad();
			ui_align(1, 1);
			ui_colora(255, 255, 255, 0.8);
			ui_textnumber(polyphony_current, "x%i");
		ui_pop();
		control_finish_enabled(1);
	ui_pop();
) : ui_screen() == "about" ? (
	control_navbar("About", -1, -1);
	
	ui_pad();

	ui_align(0.5, 0.67);
	text_height = ui_wraptext("This is a JSFX synth based on the 'padsynth' algorithm from ZynAddSubFX, which I love.  It has a focus on flexible per-note effects and modulation, and I\'m adding features as I need them.\n\nIt\'s a sample-based synth, where the samples are designed in the frequency domain (which allows customised harmonic spread) and then generated using an inverse FFT.\n\nThe GUI for this synth uses a JSFX UI library originally written for this synth, but is now a project of its own.\n\nhttps://github.com/geraintluff/jsfx-pad-synth\nhttps://github.com/geraintluff/jsfx-ui-lib");
	
	ui_push_above(text_height);
		ui_align(0.5, 0.5);
		ui_fontsize(20);
		ui_fontbold(1);
		ui_text("PadSynth");
		ui_push_belowtext("PadSynth");
			ui_fontsize(0);
			ui_fontbold(0);
			ui_fontitalic(1);
			ui_align(0.5, 0);
			ui_text("by Geraint Luff");
		ui_pop();
	ui_pop();
) : ui_screen() == "waveform" ? (
	control_navbar("Waveform", -1, -1);
	ui_pad();
	ui_split_bottomtext("");
		ui_split_righttext("Regenerate");
			control_indicator_button("Regenerate", can_recompute) ? (
				can_recompute ? action_recompute = 1;
			);
		ui_pop();
	
		ui_split_lefttext("Width (cents)");
			ui_text("Width (cents)");
		ui_pop();
		ui_split_righttext("200");
			ui_padleft();
			ui_align(0, -1);
			ui_textnumber(param_width_cents + 0.5, "%i");
		ui_pop();

		new_width_cents = control_hslider(param_width_cents, 5, 200, 3);
		new_width_cents != param_width_cents ? can_recompute = 1;
		param_width_cents = new_width_cents;
	ui_pop();
	ui_padbottom();

	ui_split_topratio(0.4);
		ui_split_rightratio(0.5);
			ui_pad4(ui_hpadding()/2, 0, 0, 0);
			ui_color(0, 0, 0);
			ui_fill();
			ui_color(192, 128, 64);
			gfx_x = ui_left();
			gfx_y = ui_top() + (0.5 - get_waveform_value(0)*0.49)*ui_height();
			while (gfx_x < ui_right() - 1) (
				g_newx = gfx_x + 1;
				g_ratio = (g_newx - ui_left())/ui_width();
				g_newy = ui_top() + (0.5 - get_waveform_value(g_ratio)*0.49)*ui_height();
				gfx_lineto(g_newx, g_newy, 1);
			);
			ui_color(0, 0, 0);
			ui_border();
			control_finish_enabled(1);
		ui_split_next();
			// Recalculate using current params
			action_recalculate_spectrum = 1;
			
			ui_pad4(0, 0, ui_hpadding()/2, 0);
			ui_color(0, 0, 0);
			ui_fill();
			ui_color(192, 128, 64);
			
			g_barwidth = floor(ui_width()/60);
			g_index = 1;
			g_left = 1;
			g_right = g_left + ceil(g_barwidth*0.7);

			while (g_left < ui_width()) (
				g_amp = get_waveform_spectrum_amp(g_index);
				g_ratio = max(0, min(1, (4 - log(g_amp))*0.15));
				gfx_rect(ui_left() + g_left, ui_top() + g_ratio*ui_height(), min(g_right - g_left, ui_width() - g_left), ui_height()*(1 - g_ratio));
				
				g_index += 1;
				g_left += g_barwidth;
				g_right += g_barwidth;
			);
			ui_color(0, 0, 0);
			ui_border();
			control_finish_enabled(1);
		ui_pop();
	ui_pop();

	control_group("Shape");
	ui_split_topratio(1/5);
		ui_push_heighttext(-1);
			ui_split_leftratio(0.2);
				ui_pad();
				ui_align(1, 0.5);
				ui_text("shape");
			ui_pop();
			
			new_param_waveform_type = control_selector(param_waveform_type, get_waveform_name(param_waveform_type), (param_waveform_type + 1)%4/*WAVEFORM: */, (param_waveform_type - 1 + 4/*WAVEFORM: */)%4/*WAVEFORM: */); 
			new_param_waveform_type != param_waveform_type ? (
				param_waveform_type = new_param_waveform_type;
				can_recompute = 1;
			);
		ui_pop();
	ui_split_next();
		ui_push_heighttext(-1);
			ui_split_leftratio(0.2);
				ui_pad();
				ui_align(1, 0.5);
				ui_text("warp type");
			ui_pop();
			
			new_param_waveform_warptype = control_selector(param_waveform_warptype, get_warptype_name(param_waveform_warptype), (param_waveform_warptype + 1)%4/*WAVEFORM_WARPTYPE: */, (param_waveform_warptype - 1 + 4/*WAVEFORM_WARPTYPE: */)%4/*WAVEFORM_WARPTYPE: */); 
			new_param_waveform_warptype != param_waveform_warptype ? (
				param_waveform_warptype = new_param_waveform_warptype;
				can_recompute = 1;
			);
		ui_pop();
	ui_split_next();
		ui_push_heighttext(-1);
			ui_split_leftratio(0.2);
				ui_pad();
				ui_align(1, 0.5);
				ui_text("warp strength");
			ui_pop();
			
			new_param_waveform_warpamount = control_hslider(param_waveform_warpamount, 0, 5, 2);
			new_param_waveform_warpamount != param_waveform_warpamount ? (
				param_waveform_warpamount = new_param_waveform_warpamount;
				can_recompute = 1;
			);
		ui_pop();
	ui_split_next();
		ui_push_heighttext(-1);
			ui_split_leftratio(0.2);
				ui_pad();
				ui_align(1, 0.5);
				ui_text("mod");
			ui_pop();
			
			new_param_waveform_mod1strength = control_hslider(param_waveform_mod1strength, 0, 3, 3);
			new_param_waveform_mod1strength != param_waveform_mod1strength ? (
				param_waveform_mod1strength = new_param_waveform_mod1strength;
				can_recompute = 1;
			);
		ui_pop();
	ui_split_next();
		ui_push_heighttext(-1);
			ui_split_leftratio(0.2);
				ui_pad();
				ui_align(1, 0.5);
				ui_text("mod phase");
			ui_pop();
			
			new_param_waveform_mod1phase = control_hslider(param_waveform_mod1phase, 0, 2*$pi, 0);
			new_param_waveform_mod1phase != param_waveform_mod1phase ? (
				param_waveform_mod1phase = new_param_waveform_mod1phase;
				can_recompute = 1;
			);
		ui_pop();
	ui_pop();
	
) : ui_screen() == "envelope" ? (
	control_navbar("Envelope (ADSR)", -1, -1);
	ui_split_topratio(1/5);
		ui_push_heighttext(-1);
			ui_split_leftratio(0.2);
				ui_padright();
				ui_align(1, -1);
				ui_text("Attack");
			ui_pop();
			ui_split_rightratio(0.2);
				ui_padleft();
				ui_align(0, -1);
				ui_textnumber(floor(param_attack*1000 + 0.5), "%ims");
			ui_pop();
			param_attack = control_hslider(param_attack, 0.001, 1.5, 3);
		ui_pop();
	ui_split_next();
		ui_push_heighttext(-1);
			ui_split_leftratio(0.2);
				ui_padright();
				ui_align(1, -1);
				ui_text("Decay");
			ui_pop();
			ui_split_rightratio(0.2);
				ui_padleft();
				ui_align(0, -1);
				ui_textnumber(floor(param_decay*1000 + 0.5), "%ims");
			ui_pop();
			param_decay = control_hslider(param_decay, 0.001, 5, 3);
		ui_pop();
	ui_split_next();
		ui_push_heighttext(-1);
			ui_split_leftratio(0.2);
				ui_padright();
				ui_align(1, -1);
				ui_text("Sustain");
			ui_pop();
			ui_split_rightratio(0.2);
				ui_padleft();
				ui_align(0, -1);
				ui_textnumber(floor(param_sustain*100 + 0.5), "%i%%");
			ui_pop();
			param_sustain = control_hslider(param_sustain, 0, 1, 0);
		ui_pop();
	ui_split_next();
		ui_push_heighttext(-1);
			ui_split_leftratio(0.2);
				ui_padright();
				ui_align(1, -1);
				ui_text("Release");
			ui_pop();
			ui_split_rightratio(0.2);
				ui_padleft();
				ui_align(0, -1);
				ui_textnumber(floor(param_release*1000 + 0.5), "%ims");
			ui_pop();
			param_release = control_hslider(param_release, 0.005, 5, 3);
		ui_pop();
	ui_split_next();
		ui_push_heighttext(-1);
			ui_split_leftratio(0.2);
				ui_padright();
				ui_align(1, -1);
				ui_text("Curve");
			ui_pop();
			ui_split_rightratio(0.2);
			ui_pop();
			
			ui_align(0, -1); // Align left
			param_env_linear = control_selector(param_env_linear, param_env_linear ? "Linear" : "Tapered", !param_env_linear, !param_env_linear);
		ui_pop();
	ui_pop();
) : ui_screen() == "list-effects" ? (
	g_effect_index = 0;
	control_navbar("", -1, -1);
	ui_split_bottomtext(-1);
		control_indicator_button("add effect", fx_list_count < fx_list_maxcount) ? (
			fx_list_count < fx_list_maxcount ? ui_screen_open("add-effect");
		);
	ui_pop();

	// Mouse-up applies to whole list, and comes first - otherwise when dragging downwards, the source index gets cleared before we get to dropped one
	ui_mouse_up() && g_drageffect_index >= 0 && g_drageffect_targetindex >= 0 ? (
		while (g_drageffect_targetindex > g_drageffect_index) (
			effect_swap(g_drageffect_index, g_drageffect_index + 1);
			g_drageffect_index += 1;
		);
		while (g_drageffect_targetindex < g_drageffect_index) (
			effect_swap(g_drageffect_index, g_drageffect_index - 1);
			g_drageffect_index -= 1;
		);
		g_drageffect_index = -1;
	);
	
	ui_split_topratio(1/fx_list_maxcount);
	while (g_effect_index < fx_list_maxcount) (
		g_effect_index < fx_list_count ? (
			g_effect = fx_list_start + fx_list_step*g_effect_index;
			g_effect_spec = fx_spec_start + fx_spec_step*g_effect[0/*FX:SPEC_INDEX*/];
			ui_color(0, 0, 0);
			ui_split_rightratio(0.15) ? (
				control_button("edit") ? (
					ui_screen_open("edit-effect");
					ui_screen_set(0, g_effect);
					ui_screen_set(1, g_effect_index);
				);
			);
			ui_pop();
			
			// Double-click to edit name
			ui_click() && ui_clickcount() == 2 ? (
				ui_screen_open("control.prompt");
				ui_screen_set(0, g_effect[1/*FX:NAME*/]);
				ui_screen_set(1, "Rename effect");
			);
			
			// Drag to re-order
			ui_drag() ? (
				g_drageffect_index = g_effect_index;
			) : (
				g_drageffect_index == g_effect_index ? (
					g_drageffect_index = -1;
				);
			);
			// Drop to re-order
			ui_hover() && g_drageffect_index >= 0 ? (
				g_drageffect_targetindex = g_effect_index;
				g_effect_index < g_drageffect_index ? (
					ui_mouse_yratio() < 0.5 ? (
						g_drageffect_targetindex = g_effect_index;
					) : (
						g_drageffect_targetindex = g_effect_index + 1;
					);
				) : g_effect_index > g_drageffect_index ? (
					ui_mouse_yratio() < 0.5 ? (
						g_drageffect_targetindex = g_effect_index - 1;
					) : (
						g_drageffect_targetindex = g_effect_index;
					);
				);
			);
			
			strlen(g_effect[1/*FX:NAME*/]) == 0 ? (
				strcpy(g_effect[1/*FX:NAME*/], g_effect_spec[0/*FX_HEADER:NAME*/]);
			);
			g_drageffect_index == g_effect_index ? (
				ui_color(160, 160, 160);
				ui_fill();
				ui_color(255, 255, 255);
				ui_text(g_effect[1/*FX:NAME*/]);
			) : (
				(g_effect_index%2) ? (
					ui_colora(255, 255, 255, 1);
					ui_fill();
				);
				ui_color(0, 0, 0);
				ui_text(g_effect[1/*FX:NAME*/]);
			);
			
			ui_color(0, 0, 0);
			ui_hover() && g_drageffect_index >= 0 ? (
				ui_mouse_yratio() < 0.5 ? (
					ui_border_top();
				) : (
					ui_border_bottom();
				);
			);

			ui_colora(0, 0, 0, 0.1);
			ui_border_bottom();
		);

		g_effect_index += 1;
		ui_split_next();
	);
	ui_pop();
) : ui_screen() == "automation-target" ? (
	control_dialog("Select effect", 0, 0, -1, "cancel");
	g_arg_effect = ui_screen_get(0);
	g_arg_index = ui_screen_get(1);
	g_arg_range = ui_screen_get(2);
	g_arg_minIndex = ui_screen_get(3);

	g_element_height = min(ui_texth() + ui_vpadding()*2, ui_height()/(fx_list_count + 1));
	ui_split_top(g_element_height);
		ui_hover() ? (
			control_button("Note");
		) : (
			ui_color(255, 255, 255);
			ui_fill();
			ui_color(0, 0, 0);
			ui_text("Note");
			ui_colora(0, 0, 0, 0.1);
			ui_border_bottom();
		);
		ui_click() ? (
			ui_screen_close("automation-target");
			ui_screen_open("automation-target-index");
			ui_screen_set(0, g_arg_effect);
			ui_screen_set(1, g_arg_index);
			ui_screen_set(2, g_arg_range);
			ui_screen_set(3, -1);
		);
	ui_split_next();
		gi = 0;
		while (gi < fx_list_count) (
			g_effect = fx_list_start + fx_list_step*gi;
			
			(gi <= g_arg_minIndex) ? (
				ui_color(224, 224, 224);
				ui_fill();
				ui_color(180, 180, 180);
				ui_text(g_effect[1/*FX:NAME*/]);
			) : (
				ui_hover() ? (
					control_button(g_effect[1/*FX:NAME*/]);
				) : (
					ui_color(255, 255, 255);
					ui_fill();
					ui_color(0, 0, 0);
					ui_text(g_effect[1/*FX:NAME*/]);
					ui_colora(0, 0, 0, 0.1);
					ui_border_bottom();
				);
				
				ui_click() ? (
					ui_screen_close("automation-target");
					ui_screen_open("automation-target-index");
					ui_screen_set(0, g_arg_effect);
					ui_screen_set(1, g_arg_index);
					ui_screen_set(2, g_arg_range);
					ui_screen_set(3, gi);
				);
			);
		
			ui_split_next();
			gi += 1;
		);
	ui_pop();
) : ui_screen() == "automation-target-index" ? (
	control_dialog("Select parameter", 0, 0, -1, "cancel");
	g_arg_effect = ui_screen_get(0);
	g_arg_index = ui_screen_get(1);
	g_arg_range = ui_screen_get(2);
	g_effect_index = ui_screen_get(3);

	g_effect_index >= 0 ? (
		g_effect = fx_list_start + fx_list_step*g_effect_index;
		g_effect_spec = fx_spec_start + fx_spec_step*g_effect[0/*FX:SPEC_INDEX*/];
		g_effect_modcount = g_effect_spec[1/*FX_HEADER:MODCOUNT*/];
	) : (
		g_effect_modcount = 3;
	);
	
	g_element_height = min(ui_texth() + ui_vpadding()*2, ui_height()/max(1, g_effect_modcount));
	ui_split_top(g_element_height);
		gi = 0;
		while (gi < g_effect_modcount) (
			g_mod_name = get_mod_name(g_effect_index, gi);
			
			ui_hover() ? (
				control_button(g_mod_name);
			) : (
				ui_color(255, 255, 255);
				ui_fill();
				ui_color(0, 0, 0);
				ui_text(g_mod_name);
				ui_colora(0, 0, 0, 0.1);
				ui_border_bottom();
			);
			
			ui_click() ? (
				g_arg_effect[0] = g_effect_index;
				g_arg_index[0] = gi;
				g_arg_range[0] = get_mod_range(g_effect_index, gi)*0.5;
				ui_screen_close("automation-target-index");
			);
		
			ui_split_next();
			gi += 1;
		);
	ui_pop();
) : ui_screen() == "add-effect" ? (
	control_dialog("Add effect", 0, 0, -1, "cancel");
	gi = 0;
	g_element_height = min(ui_texth() + ui_vpadding()*2, ui_height()/fx_spec_count);
	while (gi < fx_spec_count) (
		ui_split_top(g_element_height);
			g_spec = fx_spec_start + fx_spec_step*gi;
			ui_hover() ? (
				control_button(g_spec[0/*FX_HEADER:NAME*/]);
			) : (
				ui_color(255, 255, 255);
				ui_fill();
				ui_color(0, 0, 0);
				ui_text(g_spec[0/*FX_HEADER:NAME*/]);
				ui_colora(0, 0, 0, 0.1);
				ui_border_bottom();
			);
			
			ui_click() ? (
				append_effect(gi);
				ui_screen_close("add-effect");
			);
		ui_pop();
		gi += 1;
	);
) : ui_screen() == "edit-effect" ? (
	g_effect = ui_screen_get(0);
	g_effect_index = ui_screen_get(1);
	g_effect_spec = fx_spec_start + fx_spec_step*g_effect[0/*FX:SPEC_INDEX*/];

	control_navbar(g_effect[1/*FX:NAME*/], "Delete", 0) == 1 ? (
		ui_screen_open("delete-effect");
		ui_screen_set(0, g_effect);
		ui_screen_set(1, g_effect_index);
	);
	effect_ui = g_effect_spec[3/*FX_HEADER:CONFIG_UI_FUNCTION*/];
	config_ui(effect_ui, g_effect);
) : ui_screen() == "delete-effect" ? (
	g_effect = ui_screen_get(0);
	g_effect_index = ui_screen_get(1);
	control_dialog("Confirm delete", 0, 0, "delete", "cancel") == 1 ? (
		effect_delete(g_effect_index);
		ui_screen_close_to("list-effects");
	);
	ui_split_topratio(0.5);
		ui_align(0.5, 1);
		ui_color(128, 0, 0);
		ui_text("Delete effect:");
	ui_split_next();
		ui_align(0.5, 0);
		ui_color(0, 0, 0);
		ui_text(get_effect_name(g_effect_index));
	ui_pop();
) : control_system();

@serialize

//////////////// Save/Restore ////////////////

// Serialisation is a sequence of (id, length, value).  All unrecognised IDs (currently) result in an error.
// We do our own string serialisation so that we can keep track of the length.
// The VAR_ID enum values should always force a value

function read_plain_var() local(var_length, value) (
	file_var(0, var_length);
	var_length ? while(
		file_var(0, value);
		var_length -= 1;
		var_length;
	);
	value;
);
function read_string_var(string) local(vars_read, char_count, char, string_length) (
	strcpy(string, "");
	string_length = 0;
	file_var(0, char_count);
	vars_read = 1 + char_count;
	string_length < char_count ? while (
		file_var(0, char);
		str_setchar(string, string_length, char);
		string_length += 1;
		string_length < char_count;
	);
	vars_read;
);
function read_effect() local(read_length, effect, effect_index, spec_index, var_id, i, var_length, value) (
	fx_list_count < fx_list_maxcount ? (
		file_var(0, read_length);
		
		file_var(0, spec_index);
		read_length -= 1;
		// TODO: check that the effect is a known type, otherwise put a placeholder in so the indices don't get screwed up (and remove placeholders at the end)
		
		effect_index = append_effect(spec_index);
		effect = fx_list_start + fx_list_step*effect_index;
		
		read_length > 0 ? while(
			file_var(0, var_id);
			read_length -= 1;
			var_id == 104/*VAR_ID:effect_name*/ ? (
				// Point it at the correct mutable string slot
				effect[1/*FX:NAME*/] = string_fx_names_start + effect_index;
				// Read the variable into that slot
				read_length -= read_string_var(effect[1/*FX:NAME*/]);
			) : var_id == 105/*VAR_ID:effect_state*/ && effect >= 0 ? (
				file_var(0, var_length);
				read_length -= var_length + 1;
				effectstate = effect + fx_list_headerlength;
				i = 0;
				i < var_length ? while (
					file_var(0, value);
					effectstate[i] = value;
					i += 1;
					i < var_length;
				);
			) : (
				sprintf(#read_effect_error, "Unrecognised ID in effect: %f", var_id);
				ui_error(#read_effect_error);
				// Consume the data so we don't get out-of-sync and screw up the rest of the config in a potentially painful way
				file_var(0, var_length);
				read_length -= var_length + 1;
				var_length > 0 ? while (
					file_var(0, i);
					var_length -= 1;
					var_length > 0;
				);
			);
			read_length > 0;
		);
	) : (
		read_plain_var();
	);
);
function read_var() local(var_id, i, effect) (
	file_var(0, var_id);
	var_id == 1/*VAR_ID:param_width_cents*/ ? (
		param_width_cents = read_plain_var();
	) : var_id == 2/*VAR_ID:param_waveform_type*/ ? (
		param_waveform_type = read_plain_var();
	) : var_id == 6/*VAR_ID:param_waveform_warptype*/ ? (
		param_waveform_warptype = read_plain_var();
	) : var_id == 3/*VAR_ID:param_waveform_warpamount*/ ? (
		param_waveform_warpamount = read_plain_var();
	) : var_id == 4/*VAR_ID:param_waveform_mod1strength*/ ? (
		param_waveform_mod1strength = read_plain_var();
	) : var_id == 5/*VAR_ID:param_waveform_mod1phase*/ ? (
		param_waveform_mod1phase = read_plain_var();
	) : var_id == 99/*VAR_ID:param_env_linear*/ ? (
		param_env_linear = read_plain_var();
	) : var_id == 100/*VAR_ID:param_attack*/ ? (
		param_attack = read_plain_var();
	) : var_id == 101/*VAR_ID:param_decay*/ ? (
		param_decay = read_plain_var();
	) : var_id == 102/*VAR_ID:param_sustain*/ ? (
		param_sustain = read_plain_var();
	) : var_id == 103/*VAR_ID:param_release*/ ? (
		param_release = read_plain_var();
	) : var_id == 106/*VAR_ID:effect*/ ? (
		read_effect();
	) : (
		ui_error("Unrecognised variable in state");
		read_plain_var();
	);
);
function write_plain_var(var_id, value) local(length) (
	length = 1;
	file_var(0, var_id);
	file_var(0, length);
	file_var(0, value);
);
function write_string_var(var_id, string) local(string_length, i, char) (
	file_var(0, var_id);
	string_length = strlen(string);
	file_var(0, string_length);
	i = 0;
	i < string_length ? while(
		char = str_getchar(string, i);
		file_var(0, char);
		i += 1;
		i < string_length;
	);
);
function write_buffer_var(var_id, buffer, length) local(i, value) (
	file_var(0, var_id);
	file_var(0, length);
	i = 0;
	i < length ? while(
		value = buffer[i];
		file_var(0, value);
		i += 1;
		i < length;
	);
);
function write_effects() local(i, effect, var_id, var_length) (
	i = 0;
	i < fx_list_count ? while(
		effect = fx_list_start + fx_list_step*i;

		var_id = 106/*VAR_ID:effect*/;
		var_length = 1; // Index
		var_length += 2 + strlen(effect[1/*FX:NAME*/]);
		var_length += 2 + fx_list_statelength;
		
		file_var(0, var_id);
		file_var(0, var_length);
		
		file_var(0, effect[0/*FX:SPEC_INDEX*/]);
		write_string_var(104/*VAR_ID:effect_name*/, effect[1/*FX:NAME*/]);
		write_buffer_var(105/*VAR_ID:effect_state*/, effect + fx_list_headerlength, fx_list_statelength);
		
		i += 1;
		i < fx_list_count;
	);
);

// Actual logic
file_avail(0) >= 0 ? (
	reset_to_defaults();
	file_avail(0) ? (
		fx_list_count = 0;
		while (
			read_var();
			file_avail(0);
		);
	);
	clear_all_notes();
	action_recompute = 1;
) : (
	write_plain_var(1/*VAR_ID:param_width_cents*/, param_width_cents);
	write_plain_var(2/*VAR_ID:param_waveform_type*/, param_waveform_type);
	write_plain_var(6/*VAR_ID:param_waveform_warptype*/, param_waveform_warptype);
	write_plain_var(3/*VAR_ID:param_waveform_warpamount*/, param_waveform_warpamount);
	write_plain_var(4/*VAR_ID:param_waveform_mod1strength*/, param_waveform_mod1strength);
	write_plain_var(5/*VAR_ID:param_waveform_mod1phase*/, param_waveform_mod1phase);
	write_plain_var(100/*VAR_ID:param_attack*/, param_attack);
	write_plain_var(101/*VAR_ID:param_decay*/, param_decay);
	write_plain_var(102/*VAR_ID:param_sustain*/, param_sustain);
	write_plain_var(103/*VAR_ID:param_release*/, param_release);
	write_plain_var(99/*VAR_ID:param_env_linear*/, param_env_linear);
	write_effects();
);